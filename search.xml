<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[数据库索引]]></title>
      <url>/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p><strong>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</strong></p>
<p><strong>索引的实现通常使用B树及其变种B+树</strong></p>
<hr>
<p><img src="https://image.yuanwei.me/17-3-30/50218441-file_1490840641214_7098.png" alt=""></p>
<blockquote>
<p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
</blockquote>
<hr>
<h3 id="索引的好处"><a href="#索引的好处" class="headerlink" title="索引的好处"></a>索引的好处</h3><ul>
<li>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。<h3 id="索引的不利影响"><a href="#索引的不利影响" class="headerlink" title="索引的不利影响"></a>索引的不利影响</h3></li>
<li>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。<h3 id="应该创建索引的列"><a href="#应该创建索引的列" class="headerlink" title="应该创建索引的列"></a>应该创建索引的列</h3></li>
<li>在经常需要搜索的列上，可以加快搜索的速度</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。<h3 id="不应该创建索引的列"><a href="#不应该创建索引的列" class="headerlink" title="不应该创建索引的列"></a>不应该创建索引的列</h3></li>
<li>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。<br>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。<h3 id="三种索引介绍"><a href="#三种索引介绍" class="headerlink" title="三种索引介绍"></a>三种索引介绍</h3><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4>唯一索引是不允许其中任何两行具有相同索引值的索引。<br>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。<br>在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</li>
</ul>
<hr>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。<br>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</strong></p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<hr>
<h3 id="B-树和B-树数据结构"><a href="#B-树和B-树数据结构" class="headerlink" title="B-树和B+树数据结构"></a>B-树和B+树数据结构</h3><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。</p>
<p>成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。</p>
<p>在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非也节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引时稀疏索引。</p>
<p>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<h5 id="所以-B-树有两种搜索方法："><a href="#所以-B-树有两种搜索方法：" class="headerlink" title="所以 B+树有两种搜索方法："></a>所以 B+树有两种搜索方法：</h5><ul>
<li><p>一种是按叶节点自己拉起的链表顺序搜索。</p>
</li>
<li><p>一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。</p>
</li>
</ul>
<p>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>
<h5 id="这两种处理索引的数据结构的不同之处："><a href="#这两种处理索引的数据结构的不同之处：" class="headerlink" title="这两种处理索引的数据结构的不同之处："></a><strong>这两种处理索引的数据结构的不同之处：</strong></h5><ul>
<li>B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。</li>
<li>因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。<br>c，B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> sql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL优化培训]]></title>
      <url>/%E5%86%85%E9%83%A8%E5%9F%B9%E8%AE%AD/2017-3-6%20SQL%E4%BC%98%E5%8C%96%E5%9F%B9%E8%AE%AD/</url>
      <content type="html"><![CDATA[<h3 id="1-MySQL-explain-selete-type类型"><a href="#1-MySQL-explain-selete-type类型" class="headerlink" title="1. MySQL explain selete_type类型"></a>1. MySQL explain selete_type类型</h3><p>select查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。</p>
<ul>
<li><strong>SIMPLE:</strong> 简单SELECT(不使用UNION或子查询)</li>
<li><strong>PRIMARY:</strong> 最外面的SELECT</li>
<li><strong>UNION:</strong> UNION中的第二个或后面的SELECT语句</li>
<li><strong>DEPENDENT UNION:</strong> UNION中的第二个或后面的SELECT语句,取决于外面的查询</li>
<li><strong>DEPENDENT SUBQUERY:</strong> 子查询中的第一个SELECT,取决于外面的查询</li>
<li><strong>UNION RESULT:</strong> UNION 的结果</li>
<li><strong>SUBQUERY:</strong> 子查询中的第一个SELECT</li>
<li><strong>DERIVED:</strong> 导出表的SELECT(FROM子句的子查询)</li>
</ul>
<h3 id="2-MySQL-explain-type类型"><a href="#2-MySQL-explain-type类型" class="headerlink" title="2. MySQL explain type类型"></a>2. MySQL explain type类型</h3><p>联合查询所使用的类型，数据访问类型：</p>
<ul>
<li><strong>consts：</strong> 单表中最多只有一个匹配行(主键/唯一索引)，在优化阶段即可读取到数据</li>
<li><strong>ref：</strong> 如果每次只匹配少数行，连接字段上的索引是非唯一索引，操作符必须使用=匹配，连接字段值不可为NULL</li>
<li><strong>eq_ref:</strong> 对于每个来自于前面的表的行组合,从该表中读取一行，一般用于join,单表不适合      a  b  c   nest loop join</li>
<li><strong>range：</strong> 对索引进行范围扫描，为诸如BETWEEN，IN，&gt;=，LIKE类操作提供支持</li>
<li><strong>index：</strong> 接近all，但是比all性能好。1).当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）； 2).以索引顺序从索引中查找数据行的全表扫描（无 Using Index）；3).如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思；4).如单独出现，则是用读索引来代替读行，但不用于查找</li>
<li><strong>all：</strong> 全表扫描或者范围扫描：不使用索引，顺序扫描，直接读取表上的数据(访问数据文件)</li>
</ul>
<p>平常sql语句需要选择前四种 </p>
<h3 id="3-注意的开发规范"><a href="#3-注意的开发规范" class="headerlink" title="3. 注意的开发规范"></a>3. 注意的开发规范</h3><ul>
<li>高并发量时，考虑数据冗余；</li>
<li>where后面条件顺序，连接条件写最前面，过滤性越强的，越靠前放</li>
<li>in后面的括号里数量，尽量限制在500以内，超过的话分批；</li>
<li>不要出现超过3张表的join，连接字段类型保持一致；</li>
<li>多表join时（a left join b ），where后面的条件，尽可能集中到驱动表上； left 100w 1w  （where a b order by c   a+b +c ）</li>
<li>页面上的搜索，禁止使用左模糊和全模糊匹配；</li>
<li>order by后面的字段，尽量和where后面的字段一致；</li>
<li>order by name1 desc, name2 desc,  name3 asc没法用索引；order by a.name1, b.name2 没法用索引；</li>
<li>禁止使用存储过程，触发器，视图等；</li>
<li>join条件建索引，过滤性强的字段建索引，其它情况请找DBA讨论。</li>
</ul>
<h3 id="4-优化案例"><a href="#4-优化案例" class="headerlink" title="4. 优化案例"></a>4. 优化案例</h3><p><strong>覆盖索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> waybill_id <span class="keyword">from</span> tms_waybill2 </div><div class="line"><span class="keyword">where</span> consigner_name <span class="keyword">like</span> ‘%沈阳<span class="number">1</span>网%<span class="string">';</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> waybill_id <span class="keyword">from</span> tms_waybill2 </div><div class="line"><span class="keyword">where</span> consigner_name <span class="keyword">like</span> <span class="string">'东莞1网%'</span> </div><div class="line"><span class="keyword">and</span> create_time &gt;=<span class="string">'2016-08-01 00:00:00'</span> </div><div class="line"><span class="keyword">and</span> create_time &lt;=<span class="string">'2016-08-25 00:00:00'</span>;</div></pre></td></tr></table></figure>
<p><strong>分页优化</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> <span class="number">1</span>, <span class="number">10</span>; </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> <span class="number">1000000</span>, <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>优化一：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> </div><div class="line">&gt;= (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t <span class="keyword">LIMIT</span> <span class="number">1000000</span>, <span class="number">1</span>) <span class="keyword">LIMIT</span> <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p>优化二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> </div><div class="line"><span class="keyword">BETWEEN</span> <span class="number">1000000</span> <span class="keyword">AND</span> <span class="number">1000010</span>;</div></pre></td></tr></table></figure>
<p>优化三：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t</div><div class="line"><span class="keyword">where</span> tname=‘f<span class="string">' order by id limit 300000,10) a</span></div><div class="line">left join t b </div><div class="line">on a.id=b.id;</div></pre></td></tr></table></figure>
<p><strong>批量数据导出（报表类）</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">目前的导出方法 limit m,n的方式</div><div class="line"></div><div class="line">建议修改为 create_time&gt;=‘…’  and  create_time&lt;‘…’</div></pre></td></tr></table></figure>
<p><strong>MySQL的session级优化参数</strong></p>
<p>如果一些sql，短期内没办法优化，可以考虑在session级，加上以下参数：select (….)<br>SET tmp_table_size=64<em>1024</em>1024;<br>SET sort_buffer_size=32<em>1024</em>1024;<br>SET join_buffer_size=32<em>1024</em>1024;<br>SET read_buffer_size=16<em>1024</em>1024;<br>SET read_rnd_buffer_size=16<em>1024</em>1024;<br>碰到添加session级参数的情况，请一定与DBA确认后，再添加。</p>
]]></content>
      
        <categories>
            
            <category> 内部培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8中时间日期库的20个常用使用示例]]></title>
      <url>/java/Java8%E4%B8%AD%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%BA%93%E7%9A%8420%E4%B8%AA%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>除了lambda表达式，stream以及几个小的改进之外，Java8还引入了一套全新的时间日期API，新的时间及日期API位于java.time包中，下面是里面的一些关键的类：</p>
<ul>
<li>Instant——它代表的是时间戳</li>
<li>LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</li>
<li>LocalTime——它代表的是不含日期的时间</li>
<li>LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。</li>
<li>ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。<br>新的库还增加了ZoneOffset及Zoned，可以为时区提供更好的支持。<br>以下为相关示例：<h4 id="1-如何-在Java-8中获取当天的日期"><a href="#1-如何-在Java-8中获取当天的日期" class="headerlink" title="1. 如何 在Java 8中获取当天的日期"></a>1. 如何 在Java 8中获取当天的日期</h4>Java 8中有一个叫LocalDate的类，它能用来表示今天的日期。这个类与java.util.Date略有不同，因为它只包含日期，没有时间。因此，如果你只需要表示日期而不包含时间，就可以使用它。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now(); System.out.println(<span class="string">"Today's Local date : "</span> + today);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Today&apos;s Local date : 2014-01-14</div></pre></td></tr></table></figure></p>
<p>你可以看到它创建了今天的日期却不包含时间信息。它还将日期格式化完了再输出出来，不像之前的Date类那样，打印出来的数据都是未经格式化的。</p>
<h4 id="2-如何在Java-8中获取当前的年月日"><a href="#2-如何在Java-8中获取当前的年月日" class="headerlink" title="2. 如何在Java 8中获取当前的年月日"></a>2. 如何在Java 8中获取当前的年月日</h4><p>LocalDate类中提供了一些很方便的方法可以用于提取出年月日以及其它的日期属性。使用这些方法，你可以获取到任何你所需要的日期属性，而不再需要使用java.util.Calendar这样的类了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now(); </div><div class="line"><span class="keyword">int</span> year = today.getYear(); </div><div class="line"><span class="keyword">int</span> month = today.getMonthValue(); </div><div class="line"><span class="keyword">int</span> day = today.getDayOfMonth(); </div><div class="line">System.out.printf(<span class="string">"Year : %d Month : %d day : %d \t %n"</span>, year, month, day);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Today&apos;s Local date : 2014-01-14 </div><div class="line">Year : 2014 Month : 1 day : 14</div></pre></td></tr></table></figure></p>
<p>可以看到，在Java 8中获取年月信息非常简单，只需使用对应的getter方法就好了，无需记忆，非常直观。你可以拿它和Java中老的获取当前年月日的写法进行一下比较。</p>
<h4 id="3-在Java-8中如何获取某个特定的日期"><a href="#3-在Java-8中如何获取某个特定的日期" class="headerlink" title="3. 在Java 8中如何获取某个特定的日期"></a>3. 在Java 8中如何获取某个特定的日期</h4><p>在第一个例子中，我们看到通过静态方法now()来生成当天日期是非常简单的，不过通过另一个十分有用的工厂方法LocalDate.of()，则可以创建出任意一个日期，它接受年月日的参数，然后返回一个等价的LocalDate实例。关于这个方法还有一个好消息就是它没有再犯之前API中的错，比方说，年只能从1900年开始，月必须从0开始，等等。这里的日期你写什么就是什么，比如说，下面这个例子中它代表的就是1月14日，没有什么隐藏逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>); </div><div class="line">System.out.println(<span class="string">"Your Date of birth is : "</span> + dateOfBirth);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Your Date of birth is : 2010-01-14</div></pre></td></tr></table></figure></p>
<h4 id="4-在Java-8中如何检查两个日期是否相等"><a href="#4-在Java-8中如何检查两个日期是否相等" class="headerlink" title="4. 在Java 8中如何检查两个日期是否相等"></a>4. 在Java 8中如何检查两个日期是否相等</h4><p>如果说起现实中实际的处理时间及日期的任务，有一个常见的就是要检查两个日期是否相等。你可能经常会碰到要判断今天是不是某个特殊的日子，比如生日啊，周年纪念日啊，或者假期之类。有的时候，会给你一个日期，让你检查它是不是某个日子比方说假日。下面这个例子将会帮助你在Java 8中完成这类任务。正如你所想的那样，LocalDate重写了equals方法来进行日期的比较，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">14</span>); </div><div class="line"><span class="keyword">if</span>(date1.equals(today))&#123; </div><div class="line">    System.out.printf(<span class="string">"Today %s and date1 %s are same date %n"</span>, today, date1); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">today 2014-01-14 and date1 2014-01-14 are same date</div></pre></td></tr></table></figure></p>
<p>在本例中我们比较的两个日期是相等的。同时，如果在代码中你拿到了一个格式化好的日期串，你得先将它解析成日期然后才能比较。你可以将这个例子与Java之前比较日期的方式进行下比较，你会发现它真是爽多了。</p>
<h4 id="5-在Java-8中如何检查重复事件，比如说生日"><a href="#5-在Java-8中如何检查重复事件，比如说生日" class="headerlink" title="5. 在Java 8中如何检查重复事件，比如说生日"></a>5. 在Java 8中如何检查重复事件，比如说生日</h4><p>在Java中还有一个与时间日期相关的实际任务就是检查重复事件，比如说每月的帐单日，结婚纪念日，每月还款日或者是每年交保险费的日子。如果你在一家电商公司工作的话，那么肯定会有这么一个模块，会去给用户发送生日祝福并且在每一个重要的假日给他们捎去问候，比如说圣诞节，感恩节，在印度则可能是万灯节（Deepawali）。如何在Java中判断是否是某个节日或者重复事件？使用MonthDay类。这个类由月日组合，不包含年信息，也就是说你可以用它来代表每年重复出现的一些日子。当然也有一些别的组合，比如说YearMonth类。它和新的时间日期库中的其它类一样也都是不可变且线程安全的，并且它还是一个值类（value class）。我们通过一个例子来看下如何使用MonthDay来检查某个重复的日期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>); </div><div class="line">MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth()); </div><div class="line">MonthDay currentMonthDay = MonthDay.from(today); </div><div class="line"><span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123; </div><div class="line">    System.out.println(<span class="string">"Many Many happy returns of the day !!"</span>); </div><div class="line">&#125;<span class="keyword">else</span>&#123; </div><div class="line">    System.out.println(<span class="string">"Sorry, today is not your birthday"</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Many Many happy returns of the day !!</div></pre></td></tr></table></figure></p>
<p>虽然年不同，但今天就是生日的那天，所以在输出那里你会看到一条生日祝福。你可以调整下系统的时间再运行下这个程序看看它是否能提醒你下一个生日是什么时候，你还可以试着用你的下一个生日来编写一个JUnit单元测试看看代码能否正确运行。</p>
<h4 id="6-如何在Java-8中获取当前时间"><a href="#6-如何在Java-8中获取当前时间" class="headerlink" title="6. 如何在Java 8中获取当前时间"></a>6. 如何在Java 8中获取当前时间</h4><p>这与第一个例子中获取当前日期非常相似。这次我们用的是一个叫LocalTime的类，它是没有日期的时间，与LocalDate是近亲。这里你也可以用静态工厂方法now()来获取当前时间。默认的格式是hh:mm:ss:nnn，这里的nnn是纳秒。可以和Java 8以前如何获取当前时间做一下比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime time = LocalTime.now();</div><div class="line">System.out.println(<span class="string">"local time now : "</span> + time);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Output </div><div class="line">local time now : 16:33:33.369 // in hour, minutes, seconds, nano seconds</div></pre></td></tr></table></figure>
<p>可以看到，当前时间是不包含日期的，因为LocalTime只有时间，没有日期。</p>
<h4 id="7-如何增加时间里面的小时数"><a href="#7-如何增加时间里面的小时数" class="headerlink" title="7. 如何增加时间里面的小时数"></a>7. 如何增加时间里面的小时数</h4><p>很多时候我们需要增加小时，分或者秒来计算出将来的时间。Java 8不仅提供了不可变且线程安全的类，它还提供了一些更方便的方法譬如plusHours()来替换原来的add()方法。顺便说一下，这些方法返回的是一个新的LocalTime实例的引用，因为LocalTime是不可变的，可别忘了存储好这个新的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalTime time = LocalTime.now();</div><div class="line">LocalTime newTime = time.plusHours(<span class="number">2</span>); <span class="comment">// adding two hours </span></div><div class="line">System.out.println(<span class="string">"Time after 2 hours : "</span> + newTime);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time after 2 hours : 18:33:33.369</div></pre></td></tr></table></figure></p>
<p>可以看到当前时间2小时后是16:33:33.369。现在你可以将它和Java中增加或者减少小时的老的方式进行下比较。一看便知哪种方式更好。</p>
<h4 id="8-如何获取1周后的日期"><a href="#8-如何获取1周后的日期" class="headerlink" title="8. 如何获取1周后的日期"></a>8. 如何获取1周后的日期</h4><p>这与前一个获取2小时后的时间的例子类似，这里我们将学会如何获取到1周后的日期。LocalDate是用来表示无时间的日期的，它有一个plus()方法可以用来增加日，星期，或者月，ChronoUnit则用来表示这个时间单位。由于LocalDate也是不可变的，因此任何修改操作都会返回一个新的实例，因此别忘了保存起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDate nextWeek = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS); </div><div class="line">System.out.println(<span class="string">"Today is : "</span> + today); </div><div class="line">System.out.println(<span class="string">"Date after 1 week : "</span> + nextWeek);</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Today is : 2014-01-14 </div><div class="line">Date after 1 week : 2014-01-21</div></pre></td></tr></table></figure></p>
<p>可以看到7天也就是一周后的日期是什么。你可以用这个方法来增加一个月，一年，一小时，一分钟，甚至是十年，查看下Java API中的ChronoUnit类来获取更多选项。</p>
<h4 id="9-一年前后的日期"><a href="#9-一年前后的日期" class="headerlink" title="9. 一年前后的日期"></a>9. 一年前后的日期</h4><p>这是上个例子的续集。上例中，我们学习了如何使用LocalDate的plus()方法来给日期增加日，周或者月，现在我们来学习下如何用minus()方法来找出一年前的那天。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate previousYear = today.minus(<span class="number">1</span>, ChronoUnit.YEARS); </div><div class="line">System.out.println(<span class="string">"Date before 1 year : "</span> + previousYear); </div><div class="line">LocalDate nextYear = today.plus(<span class="number">1</span>, YEARS); </div><div class="line">System.out.println(<span class="string">"Date after 1 year : "</span> + nextYear);</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Date before 1 year : 2013-01-14 </div><div class="line">Date after 1 year : 2015-01-14</div></pre></td></tr></table></figure></p>
<p>可以看到现在一共有两年，一个是2013年，一个是2015年，分别是2014的前后那年。</p>
<h4 id="10-在Java-8中使用时钟"><a href="#10-在Java-8中使用时钟" class="headerlink" title="10. 在Java 8中使用时钟"></a>10. 在Java 8中使用时钟</h4><p>Java 8中自带了一个Clock类，你可以用它来获取某个时区下当前的瞬时时间，日期或者时间。可以用Clock来替代System.currentTimeInMillis()与 TimeZone.getDefault()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Returns the current time based on your system clock and set to UTC. </span></div><div class="line">Clock clock = Clock.systemUTC(); </div><div class="line">System.out.println(<span class="string">"Clock : "</span> + clock); </div><div class="line"><span class="comment">// Returns time based on system clock zone Clock defaultClock = </span></div><div class="line">Clock.systemDefaultZone(); </div><div class="line">System.out.println(<span class="string">"Clock : "</span> + clock); </div><div class="line">Output: </div><div class="line">Clock : SystemClock[Z] </div><div class="line">Clock : SystemClock[Z]</div><div class="line">你可以用指定的日期来和这个时钟进行比较，比如下面这样：</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> Clock clock; <span class="comment">// dependency inject ... </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(LocalDate eventDate)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span>(eventDate.isBefore(LocalDate.now(clock)) &#123; </div><div class="line">            ... </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你需要对不同时区的日期进行处理的话这是相当方便的。</p>
<h4 id="11-在Java中如何判断某个日期是在另一个日期的前面还是后面"><a href="#11-在Java中如何判断某个日期是在另一个日期的前面还是后面" class="headerlink" title="11. 在Java中如何判断某个日期是在另一个日期的前面还是后面"></a>11. 在Java中如何判断某个日期是在另一个日期的前面还是后面</h4><p>这也是实际项目中常见的一个任务。你怎么判断某个日期是在另一个日期的前面还是后面，或者正好相等呢？在Java 8中，LocalDate类有一个isBefore()和isAfter()方法可以用来比较两个日期。如果调用方法的那个日期比给定的日期要早的话，isBefore()方法会返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate tomorrow = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">15</span>); 、<span class="keyword">if</span>(tommorow.isAfter(today))&#123; </div><div class="line">    System.out.println(<span class="string">"Tomorrow comes after today"</span>); </div><div class="line">&#125; </div><div class="line">LocalDate yesterday = today.minus(<span class="number">1</span>, DAYS); </div><div class="line"><span class="keyword">if</span>(yesterday.isBefore(today))&#123; </div><div class="line">    System.out.println(<span class="string">"Yesterday is day before today"</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Tomorrow comes after today </div><div class="line">Yesterday is day before today</div></pre></td></tr></table></figure></p>
<p>可以看到在Java 8中进行日期比较非常简单。不需要再用像Calendar这样的另一个类来完成类似的任务了。</p>
<h4 id="12-在Java-8中处理不同的时区"><a href="#12-在Java-8中处理不同的时区" class="headerlink" title="12. 在Java 8中处理不同的时区"></a>12. 在Java 8中处理不同的时区</h4><p>Java 8不仅将日期和时间进行了分离，同时还有时区。现在已经有好几组与时区相关的类了，比如ZonId代表的是某个特定的时区，而ZonedDateTime代表的是带时区的时间。它等同于Java 8以前的GregorianCalendar类。使用这个类，你可以将本地时间转换成另一个时区中的对应时间，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Date and time with timezone in Java 8 ZoneId america = ZoneId.of("America/New_York"); </span></div><div class="line">LocalDateTime localtDateAndTime = LocalDateTime.now(); </div><div class="line">ZonedDateTime dateAndTimeInNewYork = ZonedDateTime.of(localtDateAndTime, america ); </div><div class="line">System.out.println(<span class="string">"Current date and time in a particular timezone : "</span> + dateAndTimeInNewYork);</div></pre></td></tr></table></figure>
<p>output: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Current date and time in aparticular time zone:2014-01-14T16:33:33.373-05:00[America/New_York]</div></pre></td></tr></table></figure>
<p>可以拿它跟之前将本地时间转换成GMT时间的方式进行下比较。顺便说一下，正如Java 8以前那样，对应时区的那个文本可别弄错了，否则你会碰到这么一个异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.time.zone.ZoneRulesException: Unknown time-zone ID: ASIA/Tokyo</div><div class="line">        at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:272)</div><div class="line">        at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)</div><div class="line">        at java.time.ZoneRegion.ofId(ZoneRegion.java:120)</div><div class="line">        at java.time.ZoneId.of(ZoneId.java:403)</div><div class="line">        at java.time.ZoneId.of(ZoneId.java:351)</div></pre></td></tr></table></figure>
<h4 id="13-如何表示固定的日期，比如信用卡过期时间"><a href="#13-如何表示固定的日期，比如信用卡过期时间" class="headerlink" title="13. 如何表示固定的日期，比如信用卡过期时间"></a>13. 如何表示固定的日期，比如信用卡过期时间</h4><p>正如MonthDay表示的是某个重复出现的日子的，YearMonth又是另一个组合，它代表的是像信用卡还款日，定期存款到期日，options到期日这类的日期。你可以用这个类来找出那个月有多少天，lengthOfMonth()这个方法返回的是这个YearMonth实例有多少天，这对于检查2月到底是28天还是29天可是非常有用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">YearMonth currentYearMonth = YearMonth.now(); </div><div class="line">System.out.printf(<span class="string">"Days in month year %s:%d%n"</span>,currentYearMonth,currentYearMonth.lengthOfMonth()); </div><div class="line">YearMonth creditCardExpiry = YearMonth.of(<span class="number">2018</span>, Month.FEBRUARY); </div><div class="line">System.out.printf(<span class="string">"Your credit card expires on %s %n"</span>, creditCardExpiry);</div></pre></td></tr></table></figure>
<p>output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Days in month year 2014-01: 31 </div><div class="line">Your credit card expires on 2018-02</div></pre></td></tr></table></figure>
<h4 id="14-如何在Java-8中检查闰年"><a href="#14-如何在Java-8中检查闰年" class="headerlink" title="14. 如何在Java 8中检查闰年"></a>14. 如何在Java 8中检查闰年</h4><p>这并没什么复杂的，LocalDate类有一个isLeapYear()的方法能够返回当前LocalDate对应的那年是否是闰年。如果你还想重复造轮子的话，可以看下这段代码，这是纯用Java编写的判断某年是否是闰年的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(today.isLeapYear())&#123; </div><div class="line">    System.out.println(<span class="string">"This year is Leap year"</span>); </div><div class="line">&#125;<span class="keyword">else</span> &#123; </div><div class="line">    System.out.println(<span class="string">"2014 is not a Leap year"</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2014 is not a Leap year</div></pre></td></tr></table></figure>
<h4 id="15-两个日期之间包含多少天，多少个月"><a href="#15-两个日期之间包含多少天，多少个月" class="headerlink" title="15. 两个日期之间包含多少天，多少个月"></a>15. 两个日期之间包含多少天，多少个月</h4><p>还有一个常见的任务就是计算两个给定的日期之间包含多少天，多少周或者多少年。你可以用java.time.Period类来完成这个功能。在下面这个例子中，我们将计算当前日期与将来的一个日期之前一共隔着几个月。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDate java8Release = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">14</span>); </div><div class="line">Period periodToNextJavaRelease = Period.between(today, java8Release); </div><div class="line">System.out.println(<span class="string">"Months left between today and Java 8 release : "</span> + periodToNextJavaRelease.getMonths() );</div></pre></td></tr></table></figure>
<p>output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Months left between today and Java 8 release : 2</div></pre></td></tr></table></figure>
<p>可以看到，本月是1月，而Java 8的发布日期是3月，因此中间隔着2个月。</p>
<h4 id="16-带时区偏移量的日期与时间"><a href="#16-带时区偏移量的日期与时间" class="headerlink" title="16. 带时区偏移量的日期与时间"></a>16. 带时区偏移量的日期与时间</h4><p>在Java 8里面，你可以用ZoneOffset类来代表某个时区，比如印度是GMT或者UTC5：30，你可以使用它的静态方法ZoneOffset.of()方法来获取对应的时区。只要获取到了这个偏移量，你就可以拿LocalDateTime和这个偏移量创建出一个OffsetDateTime。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDateTime datetime = LocalDateTime.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">14</span>, <span class="number">19</span>, <span class="number">30</span>); </div><div class="line">ZoneOffset offset = ZoneOffset.of(<span class="string">"+05:30"</span>);</div><div class="line">OffsetDateTime date = OffsetDateTime.of(datetime, offset); </div><div class="line">System.out.println(<span class="string">"Date and Time with timezone offset in Java : "</span> + date);</div></pre></td></tr></table></figure>
<p>Output : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Date and Time with timezone offset in Java : 2014-01-14T19:30+05:30</div></pre></td></tr></table></figure>
<p>可以看到现在时间日期与时区是关联上了。还有一点就是，OffSetDateTime主要是给机器来理解的，如果是给人看的，可以使用ZoneDateTime类。</p>
<h4 id="17-在Java-8中如何获取当前时间戳"><a href="#17-在Java-8中如何获取当前时间戳" class="headerlink" title="17. 在Java 8中如何获取当前时间戳"></a>17. 在Java 8中如何获取当前时间戳</h4><p>如果你还记得在Java 8前是如何获取当前时间戳的，那现在这简直就是小菜一碟了。Instant类有一个静态的工厂方法now()可以返回当前时间戳，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant timestamp = Instant.now(); </div><div class="line">System.out.println(<span class="string">"What is value of this instant "</span> + timestamp);</div></pre></td></tr></table></figure>
<p>Output : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">What is value of this instant 2014-01-14T08:33:33.379Z</div></pre></td></tr></table></figure>
<p>可以看出，当前时间戳是包含日期与时间的，与java.util.Date很类似，事实上Instant就是Java 8前的Date，你可以使用这两个类中的方法来在这两个类型之间进行转换，比如Date.from(Instant)是用来将Instant转换成java.util.Date的，而Date.toInstant()是将Date转换成Instant的。</p>
<h4 id="18-如何在Java-8中使用预定义的格式器来对日期进行解析-格式化"><a href="#18-如何在Java-8中使用预定义的格式器来对日期进行解析-格式化" class="headerlink" title="18. 如何在Java 8中使用预定义的格式器来对日期进行解析/格式化"></a>18. 如何在Java 8中使用预定义的格式器来对日期进行解析/格式化</h4><p>在Java 8之前，时间日期的格式化可是个技术活，我们的好伙伴SimpleDateFormat并不是线程安全的，而如果用作本地变量来格式化的话又显得有些笨重。多亏了线程本地变量，这使得它在多线程环境下也算有了用武之地，但Java维持这一状态也有很长一段时间了。这次它引入了一个全新的线程安全的日期与时间格式器。它还自带了一些预定义好的格式器，包含了常用的日期格式。比如说，本例 中我们就用了预定义的BASICISODATE格式，它会将2014年2月14日格式化成20140114。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String dayAfterTommorrow = <span class="string">"20140116"</span>; </div><div class="line">LocalDate formatted = LocalDate.parse(dayAfterTommorrow, DateTimeFormatter.BASIC_ISO_DATE); </div><div class="line">System.out.printf(<span class="string">"Date generated from String %s is %s %n"</span>, dayAfterTommorrow, formatted);</div></pre></td></tr></table></figure>
<p>Output ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Date generated from String 20140116 is 2014-01-16</div></pre></td></tr></table></figure>
<p>你可以看到生成的日期与指定字符串的值是匹配的，就是日期格式上略有不同。</p>
<h4 id="19-如何在Java中使用自定义的格式器来解析日期"><a href="#19-如何在Java中使用自定义的格式器来解析日期" class="headerlink" title="19. 如何在Java中使用自定义的格式器来解析日期"></a>19. 如何在Java中使用自定义的格式器来解析日期</h4><p>在上例中，我们使用了内建的时间日期格式器来解析日期字符串。当然了，预定义的格式器的确不错但有时候你可能还是需要使用自定义的日期格式，这个时候你就得自己去创建一个自定义的日期格式器实例了。下面这个例子中的日期格式是”MMM dd yyyy”。你可以给DateTimeFormatter的ofPattern静态方法()传入任何的模式，它会返回一个实例，这个模式的字面量与前例中是相同的。比如说M还是代表月，而m仍是分。无效的模式会抛出DateTimeParseException异常，但如果是逻辑上的错误比如说该用M的时候用成m，这样就没办法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String goodFriday = <span class="string">"Apr 18 2014"</span>; </div><div class="line"><span class="keyword">try</span> &#123; </div><div class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy"</span>);     </div><div class="line">    LocalDate holiday = LocalDate.parse(goodFriday, formatter); </div><div class="line">    System.out.printf(<span class="string">"Successfully parsed String %s, date is %s%n"</span>, goodFriday, holiday); </div><div class="line">&#125; <span class="keyword">catch</span> (DateTimeParseException ex) &#123; </div><div class="line">    System.out.printf(<span class="string">"%s is not parsable!%n"</span>, goodFriday); </div><div class="line">    ex.printStackTrace(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Successfully parsed String Apr 18 2014, date is 2014-04-18</div></pre></td></tr></table></figure>
<p>可以看到日期的值与传入的字符串的确是相符的，只是格式不同。</p>
<h4 id="20-如何在Java-8中对日期进行格式化，转换成字符串"><a href="#20-如何在Java-8中对日期进行格式化，转换成字符串" class="headerlink" title="20. 如何在Java 8中对日期进行格式化，转换成字符串"></a>20. 如何在Java 8中对日期进行格式化，转换成字符串</h4><p>在上两个例子中，尽管我们用到了DateTimeFormatter类但我们主要是进行日期字符串的解析。在这个例子中我们要做的事情正好相反。这里我们有一个LocalDateTime类的实例，我们要将它转换成一个格式化好的日期串。这是目前为止Java中将日期转换成字符串最简单便捷的方式了。下面这个例子将会返回一个格式化好的字符串。与前例相同的是，我们仍需使用指定的模式串去创建一个DateTimeFormatter类的实例，但调用的并不是LocalDate类的parse方法，而是它的format()方法。这个方法会返回一个代表当前日期的字符串，对应的模式就是传入的DateTimeFormatter实例中所定义好的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">LocalDateTime arrivalDate = LocalDateTime.now(); </div><div class="line"><span class="keyword">try</span> &#123; </div><div class="line">    DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy hh:mm a"</span>); </div><div class="line">    String landing = arrivalDate.format(format); </div><div class="line">    System.out.printf(<span class="string">"Arriving at : %s %n"</span>, landing); </div><div class="line">    &#125; <span class="keyword">catch</span> (DateTimeException ex) &#123; </div><div class="line">    System.out.printf(<span class="string">"%s can't be formatted!%n"</span>, arrivalDate); </div><div class="line">    ex.printStackTrace(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arriving at : Jan 14 2014 04:33 PM</div></pre></td></tr></table></figure>
<p>可以看到，当前时间是用给定的”MMM dd yyyy hh:mm a”模式来表示的，它包含了三个字母表示的月份以及用AM及PM来表示的时间。</p>
<h3 id="Java-8中日期与时间API的几个关键点"><a href="#Java-8中日期与时间API的几个关键点" class="headerlink" title="Java 8中日期与时间API的几个关键点"></a>Java 8中日期与时间API的几个关键点</h3><p>看完了这些例子后，我相信你已经对Java 8这套新的时间日期API有了一定的了解了。现在我们来回顾下关于这个新的API的一些关键的要素。</p>
<ol>
<li>它提供了javax.time.ZoneId用来处理时区。</li>
<li>它提供了LocalDate与LocalTime类</li>
<li>Java 8中新的时间与日期API中的所有类都是不可变且线程安全的，这与之前的Date与Calendar API中的恰好相反，那里面像java.util.Date以及SimpleDateFormat这些关键的类都不是4. 新的时间与日期API中很重要的一点是它定义清楚了基本的时间与日期的概念，比方说，瞬时时间，持续时间，日期，时间，时区以及时间段。它们都是基于ISO日历体系的。</li>
<li>每个Java开发人员都应该至少了解这套新的API中的这五个类：</li>
</ol>
<ul>
<li>Instant 它代表的是时间戳，比如2014-01-14T02:20:13.592Z，这可以从java.time.Clock类中获取，像这样： Instant current = Clock.system(ZoneId.of(“Asia/Tokyo”)).instant();</li>
<li>LocalDate 它表示的是不带时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</li>
<li>LocalTime – 它表示的是不带日期的时间</li>
<li>LocalDateTime – 它包含了时间与日期，不过没有带时区的偏移量</li>
<li>ZonedDateTime – 这是一个带时区的完整时间，它根据UTC/格林威治时间来进行时区调整</li>
</ul>
<ol>
<li>这个库的主包是java.time，里面包含了代表日期，时间，瞬时以及持续时间的类。它有两个子package，一个是java.time.foramt，这个是什么用途就很明显了，还有一个是java.time.temporal，它能从更低层面对各个字段进行访问。</li>
<li>时区指的是地球上共享同一标准时间的地区。每个时区都有一个唯一标识符，同时还有一个地区/城市(Asia/Tokyo)的格式以及从格林威治时间开始的一个偏移时间。比如说，东京的偏移时间就是+09:00。</li>
<li>OffsetDateTime类实际上包含了LocalDateTime与ZoneOffset。它用来表示一个包含格林威治时间偏移量（+/-小时：分，比如+06:00或者 -08：00）的完整的日期（年月日）及时间（时分秒，纳秒）。</li>
<li>DateTimeFormatter类用于在Java中进行日期的格式化与解析。与SimpleDateFormat不同，它是不可变且线程安全的，如果需要的话，可以赋值给一个静态变量。DateTimeFormatter类提供了许多预定义的格式器，你也可以自定义自己想要的格式。当然了，根据约定，它还有一个parse()方法是用于将字符串转换成日期的，如果转换期间出现任何错误，它会抛出DateTimeParseException异常。类似的，DateFormatter类也有一个用于格式化日期的format()方法，它出错的话则会抛出DateTimeException异常。</li>
<li>再说一句，“MMM d yyyy”与“MMm dd yyyy”这两个日期格式也略有不同，前者能识别出”Jan 2 2014″与”Jan 14 2014″这两个串，而后者如果传进来的是”Jan 2 2014″则会报错，因为它期望月份处传进来的是两个字符。为了解决这个问题，在天为个位数的情况下，你得在前面补0，比如”Jan 2 2014″应该改为”Jan 02 2014″。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[校验算法汇总]]></title>
      <url>/java/%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h3 id="1-银行卡校验："><a href="#1-银行卡校验：" class="headerlink" title="1. 银行卡校验："></a>1. 银行卡校验：</h3><p>Luhn算法被用于最后一位为校验码的一串数字的校验，通过如下规则计算校验码的正确性：</p>
<ul>
<li>按照从右往左的顺序，从这串数字的右边开始，包含校验码，将偶数位数字乘以2，如果每次乘二操作的结果大于9（如 8 × 2 = 16），然后计算个位和十位数字的和（如 1 ＋ 6 = 7）或者用这个结果减去9（如 16 - 9 ＝ 7）；</li>
<li>第一步操作过后会得到新的一串数字，计算所有数字的和（包含校验码）；</li>
<li>用第二步操作得到的和进行“模10”运算，如果结果位0，表示校验通过，否则失败。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * 匹配Luhn算法：可用于检测银行卡卡号</div><div class="line">   * @param cardNo</div><div class="line">   * @return</div><div class="line">   */public static boolean matchLuhn(String cardNo) &#123;</div><div class="line">      int[] cardNoArr = new int[cardNo.length()];</div><div class="line">      for (int i=0; i&lt;cardNo.length(); i++) &#123;</div><div class="line">          cardNoArr[i] = Integer.valueOf(String.valueOf(cardNo.charAt(i)));</div><div class="line">      &#125;</div><div class="line">      for(int i=cardNoArr.length-2;i&gt;=0;i-=2) &#123;</div><div class="line">          cardNoArr[i] &lt;&lt;= 1;</div><div class="line">          cardNoArr[i] = cardNoArr[i]/10 + cardNoArr[i]%10;</div><div class="line">      &#125;</div><div class="line">      int sum = 0;</div><div class="line">      for(int i=0;i&lt;cardNoArr.length;i++) &#123;</div><div class="line">          sum += cardNoArr[i];</div><div class="line">      &#125;</div><div class="line">      return sum % 10 == 0;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>利用Luhn算法的规则也可以写出随机生成一个满足条件的银行卡卡号的实现代码.   </p>
<h3 id="2-身份证校验"><a href="#2-身份证校验" class="headerlink" title="2. 身份证校验"></a>2. 身份证校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line">     </div><div class="line">     </div><div class="line">   <span class="keyword">import</span> java.text.ParseException;  </div><div class="line">   <span class="keyword">import</span> java.text.SimpleDateFormat;  </div><div class="line">   <span class="keyword">import</span> java.util.Calendar;  </div><div class="line">   <span class="keyword">import</span> java.util.GregorianCalendar;  </div><div class="line">   <span class="keyword">import</span> java.util.Hashtable;  </div><div class="line">   <span class="keyword">import</span> java.util.Scanner;  </div><div class="line">   <span class="keyword">import</span> java.util.regex.Matcher;  </div><div class="line">   <span class="keyword">import</span> java.util.regex.Pattern;  </div><div class="line">     </div><div class="line">   <span class="comment">/** </span></div><div class="line">    * 身份证号码的格式：610821-20061222-612-X </div><div class="line">    * 由18位数字组成：前6位为地址码，第7至14位为出生日期码，第15至17位为顺序码， </div><div class="line">    * 第18位为校验码。检验码分别是0-10共11个数字，当检验码为“10”时，为了保证公民身份证号码18位，所以用“X”表示。虽然校验码为“X”不能更换，但若需全用数字表示，只需将18位公民身份号码转换成15位居民身份证号码，去掉第7至8位和最后1位3个数码。  </div><div class="line">    * 当今的身份证号码有15位和18位之分。1985年我国实行居民身份证制度，当时签发的身份证号码是15位的，1999年签发的身份证由于年份的扩展（由两位变为四位）和末尾加了效验码，就成了18位。 </div><div class="line">    * （1）前1、2位数字表示：所在省份的代码；  </div><div class="line">    * （2）第3、4位数字表示：所在城市的代码； </div><div class="line">    * （3）第5、6位数字表示：所在区县的代码； </div><div class="line">    * （4）第7~14位数字表示：出生年、月、日； </div><div class="line">    * （5）第15、16位数字表示：所在地的派出所的代码；  </div><div class="line">    * （6）第17位数字表示性别：奇数表示男性，偶数表示女性 </div><div class="line">    * （7）第18位数字是校检码：根据一定算法生成 </div><div class="line">    * <span class="doctag">@author</span> tong </div><div class="line">    * </div><div class="line">    */  </div><div class="line">     </div><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelCreateUserAction</span> </span>&#123;  </div><div class="line">         </div><div class="line">         </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">IDCardValidate</span><span class="params">(String IDStr)</span> <span class="keyword">throws</span> ParseException </span>&#123;          </div><div class="line">           String tipInfo = <span class="string">"该身份证有效！"</span>;<span class="comment">// 记录错误信息  </span></div><div class="line">           String Ai = <span class="string">""</span>;  </div><div class="line">           <span class="comment">// 判断号码的长度 15位或18位  </span></div><div class="line">           <span class="keyword">if</span> (IDStr.length() != <span class="number">15</span> &amp;&amp; IDStr.length() != <span class="number">18</span>) &#123;  </div><div class="line">               tipInfo = <span class="string">"身份证号码长度应该为15位或18位。"</span>;  </div><div class="line">               <span class="keyword">return</span> tipInfo;  </div><div class="line">           &#125;  </div><div class="line">             </div><div class="line">     </div><div class="line">           <span class="comment">// 18位身份证前17位位数字，如果是15位的身份证则所有号码都为数字  </span></div><div class="line">           <span class="keyword">if</span> (IDStr.length() == <span class="number">18</span>) &#123;  </div><div class="line">               Ai = IDStr.substring(<span class="number">0</span>, <span class="number">17</span>);  </div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IDStr.length() == <span class="number">15</span>) &#123;  </div><div class="line">               Ai = IDStr.substring(<span class="number">0</span>, <span class="number">6</span>) + <span class="string">"19"</span> + IDStr.substring(<span class="number">6</span>, <span class="number">15</span>);  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">if</span> (isNumeric(Ai) == <span class="keyword">false</span>) &#123;  </div><div class="line">               tipInfo = <span class="string">"身份证15位号码都应为数字 ; 18位号码除最后一位外，都应为数字。"</span>;  </div><div class="line">               <span class="keyword">return</span> tipInfo;  </div><div class="line">           &#125;  </div><div class="line">             </div><div class="line">     </div><div class="line">           <span class="comment">// 判断出生年月是否有效   </span></div><div class="line">           String strYear = Ai.substring(<span class="number">6</span>, <span class="number">10</span>);<span class="comment">// 年份  </span></div><div class="line">           String strMonth = Ai.substring(<span class="number">10</span>, <span class="number">12</span>);<span class="comment">// 月份  </span></div><div class="line">           String strDay = Ai.substring(<span class="number">12</span>, <span class="number">14</span>);<span class="comment">// 日期  </span></div><div class="line">           <span class="keyword">if</span> (isDate(strYear + <span class="string">"-"</span> + strMonth + <span class="string">"-"</span> + strDay) == <span class="keyword">false</span>) &#123;  </div><div class="line">               tipInfo = <span class="string">"身份证出生日期无效。"</span>;  </div><div class="line">               <span class="keyword">return</span> tipInfo;  </div><div class="line">           &#125;  </div><div class="line">           GregorianCalendar gc = <span class="keyword">new</span> GregorianCalendar();  </div><div class="line">           SimpleDateFormat s = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);  </div><div class="line">           <span class="keyword">try</span> &#123;  </div><div class="line">               <span class="keyword">if</span> ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) &gt; <span class="number">150</span>  </div><div class="line">                       || (gc.getTime().getTime() - s.parse(  </div><div class="line">                               strYear + <span class="string">"-"</span> + strMonth + <span class="string">"-"</span> + strDay).getTime()) &lt; <span class="number">0</span>) &#123;  </div><div class="line">                   tipInfo = <span class="string">"身份证生日不在有效范围。"</span>;  </div><div class="line">                   <span class="keyword">return</span> tipInfo;  </div><div class="line">               &#125;  </div><div class="line">           &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;  </div><div class="line">               e.printStackTrace();  </div><div class="line">           &#125; <span class="keyword">catch</span> (java.text.ParseException e) &#123;  </div><div class="line">               e.printStackTrace();  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">if</span> (Integer.parseInt(strMonth) &gt; <span class="number">12</span> || Integer.parseInt(strMonth) == <span class="number">0</span>) &#123;  </div><div class="line">               tipInfo = <span class="string">"身份证月份无效"</span>;  </div><div class="line">               <span class="keyword">return</span> tipInfo;  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">if</span> (Integer.parseInt(strDay) &gt; <span class="number">31</span> || Integer.parseInt(strDay) == <span class="number">0</span>) &#123;  </div><div class="line">               tipInfo = <span class="string">"身份证日期无效"</span>;  </div><div class="line">               <span class="keyword">return</span> tipInfo;  </div><div class="line">           &#125;  </div><div class="line">             </div><div class="line">     </div><div class="line">           <span class="comment">// 判断地区码是否有效   </span></div><div class="line">           Hashtable areacode = GetAreaCode();  </div><div class="line">           <span class="comment">//如果身份证前两位的地区码不在Hashtable，则地区码有误  </span></div><div class="line">           <span class="keyword">if</span> (areacode.get(Ai.substring(<span class="number">0</span>, <span class="number">2</span>)) == <span class="keyword">null</span>) &#123;  </div><div class="line">               tipInfo = <span class="string">"身份证地区编码错误。"</span>;  </div><div class="line">               <span class="keyword">return</span> tipInfo;  </div><div class="line">           &#125;  </div><div class="line">             </div><div class="line">           <span class="keyword">if</span>(isVarifyCode(Ai,IDStr)==<span class="keyword">false</span>)&#123;  </div><div class="line">               tipInfo = <span class="string">"身份证校验码无效，不是合法的身份证号码"</span>;  </div><div class="line">               <span class="keyword">return</span> tipInfo;  </div><div class="line">           &#125;  </div><div class="line">            </div><div class="line">             </div><div class="line">           <span class="keyword">return</span> tipInfo;  </div><div class="line">       &#125;  </div><div class="line">         </div><div class="line">         </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 判断第18位校验码是否正确 </div><div class="line">        * 第18位校验码的计算方式：  </div><div class="line">           　　1. 对前17位数字本体码加权求和  </div><div class="line">           　　公式为：S = Sum(Ai * Wi), i = 0, ... , 16  </div><div class="line">           　　其中Ai表示第i个位置上的身份证号码数字值，Wi表示第i位置上的加权因子，其各位对应的值依次为： 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2  </div><div class="line">           　　2. 用11对计算结果取模  </div><div class="line">           　　Y = mod(S, 11)  </div><div class="line">           　　3. 根据模的值得到对应的校验码  </div><div class="line">           　　对应关系为：  </div><div class="line">           　　 Y值：     0  1  2  3  4  5  6  7  8  9  10  </div><div class="line">           　　校验码： 1  0  X  9  8  7  6  5  4  3   2 </div><div class="line">        */  </div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVarifyCode</span><span class="params">(String Ai,String IDStr)</span> </span>&#123;  </div><div class="line">            String[] VarifyCode = &#123; <span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"X"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>,<span class="string">"3"</span>, <span class="string">"2"</span> &#125;;  </div><div class="line">            String[] Wi = &#123; <span class="string">"7"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>, <span class="string">"5"</span>, <span class="string">"8"</span>, <span class="string">"4"</span>, <span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"6"</span>, <span class="string">"3"</span>, <span class="string">"7"</span>,<span class="string">"9"</span>, <span class="string">"10"</span>, <span class="string">"5"</span>, <span class="string">"8"</span>, <span class="string">"4"</span>, <span class="string">"2"</span> &#125;;  </div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++) &#123;  </div><div class="line">               sum = sum + Integer.parseInt(String.valueOf(Ai.charAt(i))) * Integer.parseInt(Wi[i]);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">int</span> modValue = sum % <span class="number">11</span>;  </div><div class="line">            String strVerifyCode = VarifyCode[modValue];  </div><div class="line">            Ai = Ai + strVerifyCode;  </div><div class="line">            <span class="keyword">if</span> (IDStr.length() == <span class="number">18</span>) &#123;  </div><div class="line">                <span class="keyword">if</span> (Ai.equals(IDStr) == <span class="keyword">false</span>) &#123;  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">                     </div><div class="line">                &#125;  </div><div class="line">            &#125;   </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">       &#125;  </div><div class="line">         </div><div class="line">     </div><div class="line">       <span class="comment">/** </span></div><div class="line">        * 将所有地址编码保存在一个Hashtable中     </div><div class="line">        * <span class="doctag">@return</span> Hashtable 对象 </div><div class="line">        */  </div><div class="line">        </div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Hashtable <span class="title">GetAreaCode</span><span class="params">()</span> </span>&#123;  </div><div class="line">           Hashtable hashtable = <span class="keyword">new</span> Hashtable();  </div><div class="line">           hashtable.put(<span class="string">"11"</span>, <span class="string">"北京"</span>);  </div><div class="line">           hashtable.put(<span class="string">"12"</span>, <span class="string">"天津"</span>);  </div><div class="line">           hashtable.put(<span class="string">"13"</span>, <span class="string">"河北"</span>);  </div><div class="line">           hashtable.put(<span class="string">"14"</span>, <span class="string">"山西"</span>);  </div><div class="line">           hashtable.put(<span class="string">"15"</span>, <span class="string">"内蒙古"</span>);  </div><div class="line">           hashtable.put(<span class="string">"21"</span>, <span class="string">"辽宁"</span>);  </div><div class="line">           hashtable.put(<span class="string">"22"</span>, <span class="string">"吉林"</span>);  </div><div class="line">           hashtable.put(<span class="string">"23"</span>, <span class="string">"黑龙江"</span>);  </div><div class="line">           hashtable.put(<span class="string">"31"</span>, <span class="string">"上海"</span>);  </div><div class="line">           hashtable.put(<span class="string">"32"</span>, <span class="string">"江苏"</span>);  </div><div class="line">           hashtable.put(<span class="string">"33"</span>, <span class="string">"浙江"</span>);  </div><div class="line">           hashtable.put(<span class="string">"34"</span>, <span class="string">"安徽"</span>);  </div><div class="line">           hashtable.put(<span class="string">"35"</span>, <span class="string">"福建"</span>);  </div><div class="line">           hashtable.put(<span class="string">"36"</span>, <span class="string">"江西"</span>);  </div><div class="line">           hashtable.put(<span class="string">"37"</span>, <span class="string">"山东"</span>);  </div><div class="line">           hashtable.put(<span class="string">"41"</span>, <span class="string">"河南"</span>);  </div><div class="line">           hashtable.put(<span class="string">"42"</span>, <span class="string">"湖北"</span>);  </div><div class="line">           hashtable.put(<span class="string">"43"</span>, <span class="string">"湖南"</span>);  </div><div class="line">           hashtable.put(<span class="string">"44"</span>, <span class="string">"广东"</span>);  </div><div class="line">           hashtable.put(<span class="string">"45"</span>, <span class="string">"广西"</span>);  </div><div class="line">           hashtable.put(<span class="string">"46"</span>, <span class="string">"海南"</span>);  </div><div class="line">           hashtable.put(<span class="string">"50"</span>, <span class="string">"重庆"</span>);  </div><div class="line">           hashtable.put(<span class="string">"51"</span>, <span class="string">"四川"</span>);  </div><div class="line">           hashtable.put(<span class="string">"52"</span>, <span class="string">"贵州"</span>);  </div><div class="line">           hashtable.put(<span class="string">"53"</span>, <span class="string">"云南"</span>);  </div><div class="line">           hashtable.put(<span class="string">"54"</span>, <span class="string">"西藏"</span>);  </div><div class="line">           hashtable.put(<span class="string">"61"</span>, <span class="string">"陕西"</span>);  </div><div class="line">           hashtable.put(<span class="string">"62"</span>, <span class="string">"甘肃"</span>);  </div><div class="line">           hashtable.put(<span class="string">"63"</span>, <span class="string">"青海"</span>);  </div><div class="line">           hashtable.put(<span class="string">"64"</span>, <span class="string">"宁夏"</span>);  </div><div class="line">           hashtable.put(<span class="string">"65"</span>, <span class="string">"新疆"</span>);  </div><div class="line">           hashtable.put(<span class="string">"71"</span>, <span class="string">"台湾"</span>);  </div><div class="line">           hashtable.put(<span class="string">"81"</span>, <span class="string">"香港"</span>);  </div><div class="line">           hashtable.put(<span class="string">"82"</span>, <span class="string">"澳门"</span>);  </div><div class="line">           hashtable.put(<span class="string">"91"</span>, <span class="string">"国外"</span>);  </div><div class="line">           <span class="keyword">return</span> hashtable;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       <span class="comment">/** </span></div><div class="line">        * 判断字符串是否为数字,0-9重复0次或者多次    </div><div class="line">        * <span class="doctag">@param</span> strnum </div><div class="line">        * <span class="doctag">@return</span> </div><div class="line">        */  </div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(String strnum)</span> </span>&#123;  </div><div class="line">           Pattern pattern = Pattern.compile(<span class="string">"[0-9]*"</span>);  </div><div class="line">           Matcher isNum = pattern.matcher(strnum);  </div><div class="line">           <span class="keyword">if</span> (isNum.matches()) &#123;  </div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">           &#125; <span class="keyword">else</span> &#123;  </div><div class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       <span class="comment">/** </span></div><div class="line">        * 功能：判断字符串出生日期是否符合正则表达式：包括年月日，闰年、平年和每月31天、30天和闰月的28天或者29天 </div><div class="line">        *  </div><div class="line">        * <span class="doctag">@param</span> string </div><div class="line">        * <span class="doctag">@return</span> </div><div class="line">        */  </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDate</span><span class="params">(String strDate)</span> </span>&#123;  </div><div class="line">         </div><div class="line">           Pattern pattern = Pattern  </div><div class="line">                   .compile(<span class="string">"^((\\d&#123;2&#125;(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d&#123;2&#125;(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))?$"</span>);  </div><div class="line">           Matcher m = pattern.matcher(strDate);  </div><div class="line">           <span class="keyword">if</span> (m.matches()) &#123;  </div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">           &#125; <span class="keyword">else</span> &#123;  </div><div class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">         </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;  </div><div class="line">           </div><div class="line">           <span class="comment">//String IdCard="61082120061222612X";  </span></div><div class="line">           <span class="comment">//从控制端输入用户身份证  </span></div><div class="line">           Scanner s=<span class="keyword">new</span> Scanner(System.in);  </div><div class="line">           System.out.println(<span class="string">"请输入你的身份证号码："</span>);  </div><div class="line">           String IdCard=<span class="keyword">new</span> String(s.next());  </div><div class="line">           <span class="comment">//将身份证最后一位的x转换为大写，便于统一  </span></div><div class="line">           IdCard = IdCard.toUpperCase();  </div><div class="line">           System.out.println(IDCardValidate(IdCard));  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> util </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Ioc与工厂模式的区别]]></title>
      <url>/spring/Spring%20Ioc%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>之前小V分享面试经历时说到了这个问题，发现之前使用spring时只是单纯的使用，并没有深入思考spring的IOC相较于传统的工厂模式到底有什么优势，为什么要使用它。因此经过查找资料和参考别人的博客，记录下了这个问题。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>先通过一个例子来对比Spring Ioc与工厂模式。<br>假设有三个类，Human（人类）是接口，Chinese（中国人）是一个子类，American（美国人）是另外一个子类。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.com.chengang.spring;   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;   </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;   </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;   </div><div class="line">&#125;   </div><div class="line">  </div><div class="line"><span class="keyword">package</span> cn.com.chengang.spring;   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;   </div><div class="line"><span class="comment">/* （非 Javadoc）</span></div><div class="line">* @see cn.com.chengang.spring.Human#eat()</div><div class="line">*/  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;   </div><div class="line">System.out.println(<span class="string">"中国人对吃很有一套"</span>);   </div><div class="line">&#125;   </div><div class="line">  </div><div class="line"><span class="comment">/* （非 Javadoc）</span></div><div class="line">* @see cn.com.chengang.spring.Human#walk()</div><div class="line">*/  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;   </div><div class="line">System.out.println(<span class="string">"中国人行如飞"</span>);   </div><div class="line">&#125;   </div><div class="line">&#125;   </div><div class="line">  </div><div class="line"><span class="keyword">package</span> cn.com.chengang.spring;   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;   </div><div class="line"><span class="comment">/* （非 Javadoc）</span></div><div class="line">* @see cn.com.chengang.spring.Human#eat()</div><div class="line">*/  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;   </div><div class="line">System.out.println(<span class="string">"美国人主要以面包为主"</span>);   </div><div class="line">&#125;   </div><div class="line">  </div><div class="line"><span class="comment">/* （非 Javadoc）</span></div><div class="line">* @see cn.com.chengang.spring.Human#walk()</div><div class="line">*/  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;   </div><div class="line">System.out.println(<span class="string">"美国人以车代步，有四肢退化的趋势"</span>);   </div><div class="line">&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对以上对象采用工厂模式的用法如下"><a href="#对以上对象采用工厂模式的用法如下" class="headerlink" title="对以上对象采用工厂模式的用法如下"></a>对以上对象采用工厂模式的用法如下</h4><p>创建一个工厂类Factory，如下。这个工厂类里定义了两个字符串常量，所标识不同的人种。getHuman方法根据传入参数的字串，来判断要生成什么样的人种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.com.chengang.spring;   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;   </div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String CHINESE = <span class="string">"Chinese"</span>;   </div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String AMERICAN = <span class="string">"American"</span>;   </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> Human <span class="title">getHuman</span><span class="params">(String ethnic)</span> </span>&#123;   </div><div class="line"><span class="keyword">if</span> (ethnic.equals(CHINESE))   </div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Chinese();   </div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ethnic.equals(AMERICAN))   </div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> American();   </div><div class="line"><span class="keyword">else</span>  </div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数(人种)错误"</span>);   </div><div class="line">&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一个测试的程序，使用工厂方法来得到了不同的“人种对象”，并执行相应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.com.chengang.spring;   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;   </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </div><div class="line">Human human = <span class="keyword">null</span>;   </div><div class="line">human = <span class="keyword">new</span> Factory().getHuman(Factory.CHINESE);   </div><div class="line">human.eat();   </div><div class="line">human.walk();   </div><div class="line">human = <span class="keyword">new</span> Factory().getHuman(Factory.AMERICAN);   </div><div class="line">human.eat();   </div><div class="line">human.walk();   </div><div class="line">&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="采用Spring的IoC的用法如下"><a href="#采用Spring的IoC的用法如下" class="headerlink" title="采用Spring的IoC的用法如下"></a>采用Spring的IoC的用法如下</h4><p>在项目根目录下创建一个bean.xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">＜?xml version="1.0" encoding="UTF-8"?＞   </div><div class="line">＜!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd"＞   </div><div class="line">＜beans＞   </div><div class="line">＜bean id="Chinese" class="cn.com.chengang.spring.Chinese"/＞   </div><div class="line">＜bean id="American" class="cn.com.chengang.spring.American"/＞   </div><div class="line">＜/beans＞</div></pre></td></tr></table></figure>
<p>修改ClientTest程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.com.chengang.spring;   </div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;   </div><div class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;   </div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String CHINESE = <span class="string">"Chinese"</span>;   </div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String AMERICAN = <span class="string">"American"</span>;   </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </div><div class="line"><span class="comment">// Human human = null;   </span></div><div class="line"><span class="comment">// human = new Factory().getHuman(Factory.CHINESE);   </span></div><div class="line"><span class="comment">// human.eat();   </span></div><div class="line"><span class="comment">// human.walk();   </span></div><div class="line"><span class="comment">// human = new Factory().getHuman(Factory.AMERICAN);   </span></div><div class="line"><span class="comment">// human.eat();   </span></div><div class="line"><span class="comment">// human.walk();   </span></div><div class="line">  </div><div class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"bean.xml"</span>);   </div><div class="line">Human human = <span class="keyword">null</span>;   </div><div class="line">human = (Human) ctx.getBean(CHINESE);   </div><div class="line">human.eat();   </div><div class="line">human.walk();   </div><div class="line">human = (Human) ctx.getBean(AMERICAN);   </div><div class="line">human.eat();   </div><div class="line">human.walk();   </div><div class="line">&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个程序可以看到，ctx就相当于原来的Factory工厂，原来的Factory就可以删除掉了。然后又把Factory里的两个常量移到了ClientTest类里，整个程序结构基本一样。</p>
<p>再回头看原来的bean.xml文件的这一句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">＜bean id="Chinese" class="cn.com.chengang.spring.Chinese"/＞</div></pre></td></tr></table></figure>
<p>id就是ctx.getBean的参数值，一个字符串。class就是一个类（包名＋类名）。然后在ClientTest类里获得Chinese对象就是这么一句</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">human = (Human) ctx.getBean(CHINESE);</div></pre></td></tr></table></figure>
<p>因为getBean方法返回的是Object类型，所以前面要加一个类型转换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="1-也许有人说，IoC和工厂模式不是一样的作用吗，用IoC好象还麻烦一点。"><a href="#1-也许有人说，IoC和工厂模式不是一样的作用吗，用IoC好象还麻烦一点。" class="headerlink" title="1. 也许有人说，IoC和工厂模式不是一样的作用吗，用IoC好象还麻烦一点。"></a>1. 也许有人说，IoC和工厂模式不是一样的作用吗，用IoC好象还麻烦一点。</h4><p>举个例子，如果用户需求发生变化，要把Chinese类修改一下。那么前一种工厂模式，就要更改Factory类的方法，并且重新编译布署。而IoC只需 要将class属性改变一下，并且由于IoC利用了Java反射机制，这些对象是动态生成的，这时我们就可以热插拨Chinese对象（不必把原程序停止 下来重新编译布署）</p>
<h4 id="2-也许有人说，即然IoC这么好，那么我把系统所有对象都用IoC方式来生成。"><a href="#2-也许有人说，即然IoC这么好，那么我把系统所有对象都用IoC方式来生成。" class="headerlink" title="2. 也许有人说，即然IoC这么好，那么我把系统所有对象都用IoC方式来生成。"></a>2. 也许有人说，即然IoC这么好，那么我把系统所有对象都用IoC方式来生成。</h4><p>注意，IoC的灵活性是有代价的：设置步骤麻烦、生成对象的方式不直观、反射比正常生成对象在效率上慢一点。因此使用IoC要看有没有必要，我认为比较通用的判断方式是：用到工厂模式的地方都可以考虑用IoC模式。</p>
<h4 id="3-关于IoC的低侵入性。"><a href="#3-关于IoC的低侵入性。" class="headerlink" title="3. 关于IoC的低侵入性。"></a>3. 关于IoC的低侵入性。</h4><p>什么是低侵入性？如果你用过Struts或EJB就会发现，要继承一些接口或类，才能利用它们的框架开发。这样，系统就被绑定在Struts、EJB上 了，对系统的可移植性产生不利的影响。如果代码中很少涉及某一个框架的代码，那么这个框架就可以称做是一个低侵入性的框架。</p>
<p>Spring的侵入性很低，Humen.java、Chinese.java等几个类都不必继承什么接口或类。但在ClientTest里还是有一些 Spring的影子：FileSystemXmlApplicationContext类和ctx.getBean方式等。</p>
<p>现在，低侵入性似乎也成了判定一个框架的实现技术好坏的标准之一。</p>
<h4 id="4-spring解决的问题"><a href="#4-spring解决的问题" class="headerlink" title="4. spring解决的问题"></a>4. spring解决的问题</h4><p>Spring能有效地组织J2EE应用各层的对象。不管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象， 都可在Spring的管理下有机地协调、运行。Spring将各层的对象以松耦合的方式组织在一起，Action对象无须关心Service对象的具体实 现，Service对象无须关心持久层对象的具体实现，各层对象的调用完全面向接口。当系统需要重构时，代码的改写量将大大减少。</p>
<p>上面所说的一切都得宜于Spring的核心机制，依赖注入。依赖注入让bean与bean之间以配置文件组织在一起，而不是以硬编码的方式耦合在一起。理解依赖注入</p>
<p>依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。</p>
<p>不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:一个人(Java实例，调用者)需要一把斧子(Java实例，被调用者)。</p>
<ul>
<li><p>原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为:Java程序里的调用者自己创建被调用者。</p>
</li>
<li><p>进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应Java程序的简单工厂的设计模式。</p>
</li>
<li><p>进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应Spring的依赖注入。</p>
</li>
<li><p>对应在工作中，则有以下区别</p>
</li>
<li><p>第一种情况下，Java实例的调用者创建被调用的Java实例，必然要求被调用的Java类出现在调用者的代码里。无法实现二者之间的松耦合。</p>
</li>
<li><p>第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。</p>
</li>
<li><p>第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于Spring的管理下，二者之间的依赖关系由Spring提供。</p>
</li>
</ul>
<p><strong>所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。</strong></p>
<p>Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理。依赖注入通常有两种:</p>
<ul>
<li><p>设值注入。</p>
</li>
<li><p>构造注入。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ioc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java面试补习]]></title>
      <url>/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/java%E9%9D%A2%E8%AF%95%E8%A1%A5%E4%B9%A0/</url>
      <content type="html"><![CDATA[<ol>
<li>面试角度诠释Java工程师  </li>
</ol>
<ul>
<li><a href="http://www.importnew.com/23549.html" target="_blank" rel="external">http://www.importnew.com/23549.html</a>   </li>
<li><a href="http://www.importnew.com/23557.html" target="_blank" rel="external">http://www.importnew.com/23557.html</a></li>
</ul>
<ol>
<li>java面试参考指南：  </li>
</ol>
<ul>
<li><a href="http://www.importnew.com/12516.html" target="_blank" rel="external">http://www.importnew.com/12516.html</a>   </li>
<li><a href="http://www.importnew.com/12522.html" target="_blank" rel="external">http://www.importnew.com/12522.html</a></li>
</ul>
<ol>
<li>115个Java面试题和答案——终极列表：  </li>
</ol>
<ul>
<li><a href="http://www.importnew.com/10980.html" target="_blank" rel="external">http://www.importnew.com/10980.html</a>  </li>
<li><a href="http://www.importnew.com/11028.html" target="_blank" rel="external">http://www.importnew.com/11028.html</a>  </li>
</ul>
<ol>
<li>java查漏补缺与面试准备  </li>
</ol>
<ul>
<li><a href="https://github.com/pzxwhc/MineKnowContainer" target="_blank" rel="external">https://github.com/pzxwhc/MineKnowContainer</a></li>
</ul>
<ol>
<li>javascript诞生记</li>
</ol>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html</a>  </li>
</ul>
<ol>
<li>计算机网络查漏补缺  </li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/24001696?refer=passer" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24001696?refer=passer</a>  </li>
</ul>
<ol>
<li>数据库查漏补缺</li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/23713529?refer=passer" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23713529?refer=passer</a>  </li>
</ul>
<ol>
<li>操作系统查漏补缺</li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/23755202?refer=passer" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23755202?refer=passer</a>  </li>
</ul>
<ol>
<li>50道java线程面试题分析</li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25369368?utm_source=qq&amp;utm_medium=social" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25369368?utm_source=qq&amp;utm_medium=social</a></li>
</ul>
<ol>
<li>Java面试题收集</li>
</ol>
<ul>
<li><a href="https://gold.xitu.io/post/58a6ad5461ff4b78fca442eb" target="_blank" rel="external">https://gold.xitu.io/post/58a6ad5461ff4b78fca442eb</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习文档 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Apache与Tomcat的区别与联系]]></title>
      <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8/Apache%E4%B8%8ETomcat%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p>Apache是web服务器（静态解析，如HTML），tomcat是java应用服务器（动态解析，如JSP、PHP）。Tomcat只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。</p>
<p>我个人的理解应该这2者就像Eclipse和Myeclipse，tomcat是个相当于装了许多插件的Apache并且独立运行。</p>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ol>
<li>Apache是普通服务器，本身只支持html即普通网页，可以通过插件支持php，还可以与Tomcat连通(Apache单向连接Tomcat，就是说通过Apache可以访问Tomcat资源，反之不然)。</li>
<li>Apache只支持静态网页，但像asp、jsp、php、cgi等动态网页就需要Tomcat来处理。</li>
<li>Apache和Tomcat整合使用：<ul>
<li>如果客户端请求的是静态页面，则只需要Apache服务器响应请求；</li>
<li>如果客户端请求动态页面，则是Tomcat服务器响应请求，将解析的JSP等网页代码解析后传给Apache服务器，再经Apache返回给浏览器端。这是因为jsp是服务器端解释代码的，Tomcat只做动态代码解析，Apache回传解析好的静态代码，Apache+Tomcat这样整合就可以减少Tomcat的服务开销。</li>
</ul>
</li>
<li><p>Apache和Tomcat是独立的，在同一台服务器上可以集成。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Apache是有C语言实现的，支持各种特性和模块从而来扩展核心功能；Tomcat是Java编写的，更好的支持Servlet和JSP。</p>
</li>
<li><p>Apache是Web服务器，Web服务器传送(serves)页面使浏览器可以浏览，Web服务器专门处理HTTP请求(request)，但是应用程序服务器是通过很多协议来为应用程序提供 (serves)商业逻辑(business logic)。<br>Tomcat是运行在Apache上的应用服务器，应用程序服务器提供的是客户端应用程序可以调用(call)的方法 (methods)。它只是一个servlet(jsp也翻译成servlet)容器，可以认为是Apache的扩展，但是可以独立于apache运行。</p>
</li>
<li><p>Apache是普通服务器，本身只支持html静态普通网页。不过可以通过插件支持PHP，还可以与Tomcat连通(单向Apache连接Tomcat,就是说通过Apache可以访问Tomcat资源，反之不然)，Tomcat是jsp/servlet容器，同时也支持HTML、JSP、ASP、PHP、CGI等，其中CGI需要一些手动调试，不过很容易的。</p>
</li>
<li>Apache侧重于http server，Tomcat侧重于servlet引擎，如果以standalone方式运行，功能上Tomcat与apache等效支持JSP，但对静态网页不太理想。</li>
<li>Apache可以运行一年不重启，稳定性非常好，而Tomcat则不见得。</li>
<li>首选web服务器是Apache，但Apache解析不了的jsp、servlet才用tomcat。</li>
<li>Apache是很最开始的页面解析服务，tomcat是后研发出来的，从本质上来说tomcat的功能完全可以替代Apache，但Apache毕竟是tomcat的前辈级人物，并且市场上也有不少人还在用Apache，所以Apache还会继续存在，不会被取代，apache不能解析java的东西，但解析html速度快。<h3 id="两者整合"><a href="#两者整合" class="headerlink" title="两者整合"></a>两者整合</h3>Apache是一个web服务器环境程序，启用他可以作为web服务器使用不过只支持静态网页，不支持动态网页，如asp、jsp、php、cgi</li>
</ol>
<p>如果要在Apache环境下运行jsp就需要一个解释器来执行jsp网页，而这个jsp解释器就是Tomcat</p>
<p>那为什么还要JDK呢？因为jsp需要连接数据库的话就要jdk来提供连接数据库的驱程，所以要运行jsp的web服务器平台就需要APACHE+TOMCAT+JDK</p>
<h3 id="整合的好处"><a href="#整合的好处" class="headerlink" title="整合的好处"></a>整合的好处</h3><p>如果客户端请求的是静态页面，则只需要Apache服务器响应请求</p>
<p>如果客户端请求动态页面，则是Tomcat服务器响应请求</p>
<p>因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销</p>
]]></content>
      
        <categories>
            
            <category> 服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx知识归纳]]></title>
      <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/</url>
      <content type="html"><![CDATA[<h2 id="1-ubuntu下nginx安装"><a href="#1-ubuntu下nginx安装" class="headerlink" title="1. ubuntu下nginx安装"></a>1. ubuntu下nginx安装</h2><ul>
<li>安装gcc g++的依赖库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install build-essential</div><div class="line">apt-get install libtool</div></pre></td></tr></table></figure>
<ul>
<li><p>安装pcre依赖库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install libpcre3 libpcre3-dev</div></pre></td></tr></table></figure>
</li>
<li><p>安装zlib依赖库</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install zlib1g-dev</div></pre></td></tr></table></figure>
<ul>
<li>安装ssl依赖库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install openssl</div></pre></td></tr></table></figure>
<ul>
<li>安装nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">下载最新版本：</div><div class="line">wget http://nginx.org/download/nginx-1.11.3.tar.gz</div><div class="line">#解压：</div><div class="line">tar -zxvf nginx-1.11.3.tar.gz</div><div class="line">#进入解压目录：</div><div class="line">cd nginx-1.11.3</div><div class="line">#配置：</div><div class="line">./configure --prefix=/usr/local/nginx </div><div class="line">#编辑nginx：</div><div class="line">make</div><div class="line">注意：这里可能会报错，提示“pcre.h No such file or directory”,具体详见：http://stackoverflow.com/questions/22555561/error-building-fatal-error-pcre-h-no-such-file-or-directory</div><div class="line">需要安装 libpcre3-dev,命令为：sudo apt-get install libpcre3-dev</div><div class="line">#安装nginx：</div><div class="line">sudo make install</div><div class="line">#启动nginx：</div><div class="line">sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</div><div class="line">注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件，可以通过 -h查看帮助命令。</div><div class="line">#查看nginx进程：</div><div class="line">ps -ef|grep nginx</div></pre></td></tr></table></figure>
<h2 id="2-nginx常用命令"><a href="#2-nginx常用命令" class="headerlink" title="2. nginx常用命令"></a>2. nginx常用命令</h2><ul>
<li>启动nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx</div><div class="line"></div><div class="line">./sbin/nginx</div></pre></td></tr></table></figure>
<ul>
<li>停止nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./sbin/nginx -s stop</div><div class="line"> </div><div class="line">./sbin/nginx -s quit</div></pre></td></tr></table></figure>
<ul>
<li>nginx重新加载配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./sbin/nginx -s reload</div></pre></td></tr></table></figure>
<h2 id="3-配置https"><a href="#3-配置https" class="headerlink" title="3. 配置https"></a>3. 配置https</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apt-get install openssl</div><div class="line"> </div><div class="line">apt-get install libssl-dev</div><div class="line"></div><div class="line">./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module</div><div class="line"></div><div class="line">make</div><div class="line"></div><div class="line">make install</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 命令总结]]></title>
      <url>/%E5%B7%A5%E5%85%B7/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">韩雪峰的git教程</a></p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># 安装Git</div><div class="line">$ sudo apt install git</div><div class="line"></div><div class="line"># 配置个人信息</div><div class="line">$ git config --global user.name &quot;Your Name&quot;</div><div class="line">$ git config --global user.email &quot;email@example.com&quot;</div><div class="line"></div><div class="line"># 切换目录初始化</div><div class="line">$ git init</div><div class="line"></div><div class="line"># 文件添加到仓库</div><div class="line">$ git add -p &lt;file&gt;</div><div class="line"></div><div class="line"># 把文件提交到仓库</div><div class="line">$ git commit -m &quot;add LICENSE&quot;</div><div class="line"></div><div class="line"># 查看仓库当前状态</div><div class="line">$ git status</div><div class="line"></div><div class="line"># 查看difference</div><div class="line">$ git diff</div><div class="line"></div><div class="line"># 显示从最近到最远的提交日志</div><div class="line">$ git log --pretty=oneline # 格式化输出信息</div><div class="line"></div><div class="line"># 版本退回</div><div class="line">$ git reset --hard HEAD^ # 当前版本HEAD,上一个版本HEAD^,上上个版本HEAD^^</div><div class="line">$ git reset --hard 130f10a # 或HEAD~100</div><div class="line"></div><div class="line"># 查看命令记录</div><div class="line">$ git reflog</div><div class="line"></div><div class="line"># 丢弃工作区的修改，回到最近一次git commit或git add时的状态：</div><div class="line">$ git checkout -- README.md</div><div class="line"></div><div class="line"># 把暂存区的修改撤销掉（unstage）</div><div class="line">$ git reset HEAD READER.md</div><div class="line"></div><div class="line"># 从版本库中删除该文件</div><div class="line">$ git rm README.md</div><div class="line">$ git commit -m &quot;remove READER.md&quot;</div><div class="line"></div><div class="line"># 把误删的文件恢复到最新版本，checkout其实用版本库里的版本替换工作区的版本</div><div class="line">$ git checkout -- README.md</div></pre></td></tr></table></figure>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</div><div class="line"># 测试是否成功</div><div class="line">$ ssh -T git@github.com</div><div class="line"></div><div class="line"># 把一个已有的本地仓库与之关联</div><div class="line">$ git remote add origin git@github.com:Windrivder/Windrivder.git</div><div class="line"></div><div class="line"># 把本地库的所有内容推送到远程库上（推送master分支的内容）</div><div class="line">$ git push -u origin master</div><div class="line"></div><div class="line"># 向远程库推送更新</div><div class="line">$ git push origin master</div><div class="line"></div><div class="line"># 从远程库克隆</div><div class="line">$ git clone git@github.com:michaelliao/gitskills.git</div></pre></td></tr></table></figure>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"># 创建+切换dev分支</div><div class="line">$ git checkout -b dev</div><div class="line"></div><div class="line"># 相当于</div><div class="line">$ git branch dev # 创建分支</div><div class="line">$ git checkout dev</div><div class="line"></div><div class="line"># 查看当前分支，当前分支前面标有×号</div><div class="line">$ git branch</div><div class="line"></div><div class="line"># 切换回master分支</div><div class="line">$ git checkout master</div><div class="line"></div><div class="line"># 合并指定分支到当前分支</div><div class="line">$ git merge dev</div><div class="line"></div><div class="line"># 删除dev分支</div><div class="line">$ git branch -d dev</div><div class="line"></div><div class="line"># 查看分支合并情况</div><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div><div class="line">*   59bc1cb conflict fixed</div><div class="line">|\</div><div class="line">| * 75a857c AND simple</div><div class="line">* | 400b400 &amp; simple</div><div class="line">|/</div><div class="line">* fec145a branch test</div><div class="line"></div><div class="line"># 删除feature1分支</div><div class="line">$ git branch -d feature1</div><div class="line"></div><div class="line"># 创建并切换dev分支</div><div class="line">$ git checkout -b dev</div><div class="line"></div><div class="line"># 修改readme.txt文件，并提交一个新的commit</div><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m &quot;add merge&quot;</div><div class="line"></div><div class="line"># 切换回master</div><div class="line">$ git checkout master</div><div class="line"></div><div class="line"># 合并dev分支，请注意--no-ff参数，表示禁用Fast forward</div><div class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</div><div class="line"></div><div class="line"># 看看分支历史</div><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div><div class="line">*   7825a50 merge with no-ff</div><div class="line">|\</div><div class="line">| * 6224937 add merge</div><div class="line">|/</div><div class="line">*   59bc1cb conflict fixed</div><div class="line"></div><div class="line"># 如果需要临时修复Bug，可以把当前工作现场“储藏”起来，等Bug修复后恢复现场后继续工作</div><div class="line">$ git stash</div><div class="line"></div><div class="line"># 此时查看工作区是干净</div><div class="line"># 切换到需要修复Bug的分支，创建临时分支来修复</div><div class="line">$ git checkout master</div><div class="line">$ git checkout -b issue-101</div><div class="line"></div><div class="line"># 修复完成后切换到master分支，完成合并，删除临时分支</div><div class="line">$ git checkout master</div><div class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line">$ git branch -d issue-101</div><div class="line"></div><div class="line"># Bug修复后，切换回dev分支继续干活</div><div class="line">$ git checkout dev</div><div class="line"></div><div class="line"># 查看工作现场列表</div><div class="line">$ git stash list</div><div class="line"></div><div class="line"># 恢复工作现场</div><div class="line">$ git stash pop # 恢复的同时把stash内容也删了</div><div class="line">$ git stash apply # 恢复，不删除stash的内容，使用git stash drop</div><div class="line"></div><div class="line"># 再次查看工作现场列表，干净</div><div class="line">$ git stash list</div><div class="line"></div><div class="line"># 可以多次stash，恢复时指定恢复</div><div class="line">$ git stash apply stash@&#123;0&#125;</div><div class="line"></div><div class="line"># 强行删除一个没有合并过的分支</div><div class="line">$ git branch -D &lt;name&gt;</div><div class="line"></div><div class="line"># 要查看远程库的信息</div><div class="line">$ git remote</div><div class="line">$ git remote -v</div><div class="line"></div><div class="line"># 推送其他分支</div><div class="line">$ git push origin dev</div><div class="line"></div><div class="line"># 从远程库clone，默认情况只能看到master分支，需要在dev分支，必须创建远程origin的dev分支到本地</div><div class="line">$ git checkout -b dev origin/dev</div><div class="line">$ git checkout -b branch-name origin/branch-name</div><div class="line">$ git branch --set-upstream branch-name origin/branch-name # 关联</div><div class="line"></div><div class="line"># 向远程库推送dev有冲突</div><div class="line">$ git pull # 抓取到本地合并解决冲突，再向远程推送</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># 切换到需要打标签的分支</div><div class="line">$ git branch</div><div class="line">$ git checkout master</div><div class="line"></div><div class="line"># 创建标签</div><div class="line">$ git tag v1.0</div><div class="line"></div><div class="line"># 查看所有标签</div><div class="line">$ git tag</div><div class="line"></div><div class="line"># 给历史提高的commit id打标签</div><div class="line">$ git log --pretty=oneline --abbrev-commit # 查看commit id</div><div class="line">$ git tag v0.9 6224937</div><div class="line"></div><div class="line"># 查看标签信息</div><div class="line">$ git show v0.9</div><div class="line"></div><div class="line"># 创建带有说明的标签</div><div class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164</div><div class="line"></div><div class="line"># 用PGP签名标签</div><div class="line">$ git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</div><div class="line"></div><div class="line"># 推送某个标签到远程</div><div class="line">$ git push origin v1.0</div><div class="line"></div><div class="line"># 一次性推送全部尚未推送到远程的本地标签</div><div class="line">$ git push origin --tags</div><div class="line"></div><div class="line"># 删除远程标签</div><div class="line">$ git tag -d v0.9 # 删除本地</div><div class="line">$ git push origin :refs/tags/v0.9 # 删除远程</div></pre></td></tr></table></figure>
<h3 id="自定义-Git"><a href="#自定义-Git" class="headerlink" title="自定义 Git"></a>自定义 Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 显示颜色，会让命令输出看起来更醒目</div><div class="line">$ git config --global color.ui true</div><div class="line"></div><div class="line"># 忽略某些文件时，需要编写.gitignore，然后将.gitignore放到版本库中</div><div class="line"># st就表示status</div><div class="line">$ git config --global alias.st status</div><div class="line"></div><div class="line"># 配置一个unstage别名</div><div class="line">$ git config --global alias.unstage &apos;reset HEAD&apos;</div><div class="line">$ git unstage test.py # 等价于</div><div class="line">$ git reset HEAD test.py</div><div class="line"></div><div class="line"># 显示最后一次提交信息</div><div class="line">$ git config --global alias.last &apos;log -1&apos;</div><div class="line"></div><div class="line"># log</div><div class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div><div class="line"># 每个仓库的配置文件放在.git/config</div><div class="line"># 当前用户的配置文件放在用户主目录下的一个隐藏文件.gitconfig中</div></pre></td></tr></table></figure>
<h3 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h3><h4 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git</div></pre></td></tr></table></figure>
<h4 id="创建一个-git-用户，用来运行-git-服务"><a href="#创建一个-git-用户，用来运行-git-服务" class="headerlink" title="创建一个 git 用户，用来运行 git 服务"></a>创建一个 git 用户，用来运行 git 服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo adduser git</div></pre></td></tr></table></figure>
<h4 id="创建证书登录"><a href="#创建证书登录" class="headerlink" title="创建证书登录"></a>创建证书登录</h4><p>收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 /home/git/.ssh/authorized_keys 文件里，一行一个</p>
<h4 id="初始化-Git-仓库"><a href="#初始化-Git-仓库" class="headerlink" title="初始化 Git 仓库"></a>初始化 Git 仓库</h4><p>选定一个目录作为 Git 仓库，假定是 /srv/sample.git，在 /srv 目录下输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo git init --bare sample.git</div><div class="line"># 把 owner 改为 git</div><div class="line">$ sudo chown -R git:git sample.git</div></pre></td></tr></table></figure>
<h4 id="禁用-shell-登录"><a href="#禁用-shell-登录" class="headerlink" title="禁用 shell 登录"></a>禁用 shell 登录</h4><p>编辑/etc/passwd文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git:x:1001:1001:,,,:/home/git:/bin/bash # 修改成下面的内容</div><div class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</div></pre></td></tr></table></figure>
<h4 id="克隆远程仓库，在各自的电脑上运行："><a href="#克隆远程仓库，在各自的电脑上运行：" class="headerlink" title="克隆远程仓库，在各自的电脑上运行："></a>克隆远程仓库，在各自的电脑上运行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone git@server:/srv/sample.git</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap遍历的两种方式]]></title>
      <url>/java/HashMap%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="HashMap遍历的两种方式，推荐使用entrySet"><a href="#HashMap遍历的两种方式，推荐使用entrySet" class="headerlink" title="HashMap遍历的两种方式，推荐使用entrySet()"></a>HashMap遍历的两种方式，推荐使用entrySet()</h3><h3 id="1-第一种"><a href="#1-第一种" class="headerlink" title="1. 第一种"></a>1. 第一种</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map map = new HashMap(); </div><div class="line">Iterator iter = map.entrySet().iterator(); </div><div class="line">while (iter.hasNext()) &#123; </div><div class="line">    Map.Entry entry = (Map.Entry) iter.next(); </div><div class="line">    Object key = entry.getKey(); </div><div class="line">    Object val = entry.getValue(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效率高,以后一定要使用此种方式！<br>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();  </div><div class="line">  </div><div class="line">for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;  </div><div class="line">  </div><div class="line">    System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue());  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-第二种"><a href="#2-第二种" class="headerlink" title="2. 第二种"></a>2. 第二种</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Map map = new HashMap(); </div><div class="line">Iterator iter = map.keySet().iterator(); </div><div class="line">while (iter.hasNext()) &#123; </div><div class="line">    Object key = iter.next(); </div><div class="line">    Object val = map.get(key); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效率低,以后尽量少使用！ </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于keySet其实是遍历了2次，一次是转为iterator，一次就从hashmap中取出key所对于的value。而entryset只是遍历了第一次，他把key和value都放到了entry中，所以就快了。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java集合学习系列：ArrayList的实现原理]]></title>
      <url>/java/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%9AArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本章转载自：<a href="http://zhangshixi.iteye.com/blog/674856" target="_blank" rel="external">http://zhangshixi.iteye.com/blog/674856</a></p>
<h3 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h3><p>ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p>
<p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p>
<p>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p>
<h3 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h3><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p>
<h4 id="1-底层使用数组实现"><a href="#1-底层使用数组实现" class="headerlink" title="1. 底层使用数组实现"></a>1. 底层使用数组实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h4><p>ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">this</span>(<span class="number">10</span>);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>();  </div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);  </div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    elementData = c.toArray();  </div><div class="line">    size = elementData.length;  </div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)  </span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)  </div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-存储"><a href="#3-存储" class="headerlink" title="3. 存储"></a>3. 存储</h4><p>ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解.</p>
<h5 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">    elementData[index] = element;  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    ensureCapacity(size + <span class="number">1</span>);   </div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。  </span></div><div class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);  </div><div class="line">    <span class="comment">// 如果数组长度不足，将进行扩容。  </span></div><div class="line">    ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line">    <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，  </span></div><div class="line">    <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。  </span></div><div class="line">    <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);  </div><div class="line">    elementData[index] = element;  </div><div class="line">    size++;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(  </div><div class="line">            <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);  </div><div class="line">  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </div><div class="line">  </div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-读取"><a href="#4-读取" class="headerlink" title="4. 读取"></a>4. 读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-删除"><a href="#5-删除" class="headerlink" title="5. 删除"></a>5. 删除</h4><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    modCount++;  </div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);  </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></div><div class="line">  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。  </span></div><div class="line">                fastRemove(index);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">&#125; <span class="keyword">else</span> &#123;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;  </div><div class="line">            fastRemove(index);  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</strong></p>
<h4 id="6-调整数组容量"><a href="#6-调整数组容量" class="headerlink" title="6. 调整数组容量"></a>6. 调整数组容量</h4><p>从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;  </div><div class="line">        Object oldData[] = elementData;  </div><div class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;  </div><div class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity)  </div><div class="line">                newCapacity = minCapacity;  </div><div class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:  </span></div><div class="line">      elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p>
<p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) &#123;  </div><div class="line">        elementData = Arrays.copyOf(elementData, size);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-Fail-Fast机制"><a href="#7-Fail-Fast机制" class="headerlink" title="7.  Fail-Fast机制"></a>7.  Fail-Fast机制</h4><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java集合学习系列：HashMap的实现原理]]></title>
      <url>/java/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%9AHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本章转载自：<a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="external">http://zhangshixi.iteye.com/blog/672697</a></p>
<h3 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h3><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br><img src="https://image.yuanwei.me/17-3-30/7154185-file_1490845955180_b07f.jpg" alt=""></p>
<p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。<br>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组.</p>
<p>源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * The table, resized as necessary. Length MUST Always be a power of two. </div><div class="line"> */  </div><div class="line"><span class="keyword">transient</span> Entry[] table;  </div><div class="line">  </div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">final</span> K key;  </div><div class="line">    V value;  </div><div class="line">    Entry&lt;K,V&gt; next;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<h3 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h3><h4 id="1-存储"><a href="#1-存储" class="headerlink" title="1. 存储"></a>1. 存储</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </div><div class="line">    <span class="comment">// HashMap允许存放null键和null值。  </span></div><div class="line">    <span class="comment">// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。  </span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">return</span> putForNullKey(value);  </div><div class="line">    <span class="comment">// 根据key的keyCode重新计算hash值。  </span></div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </div><div class="line">    <span class="comment">// 搜索指定hash值在对应table中的索引。  </span></div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </div><div class="line">    <span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。  </span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </div><div class="line">            V oldValue = e.value;  </div><div class="line">            e.value = value;  </div><div class="line">            e.recordAccess(<span class="keyword">this</span>);  </div><div class="line">            <span class="keyword">return</span> oldValue;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。  </span></div><div class="line">    modCount++;  </div><div class="line">    <span class="comment">// 将key、value添加到i索引处。  </span></div><div class="line">    addEntry(hash, key, value, i);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，把当前的第i个元素Entriy对象（链表的位置并为改变）做为欲put的那个元素的next值。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的i索引处。addEntry 是 HashMap 提供的一个包访问权限的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 获取指定 bucketIndex 索引处的 Entry   </span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];  </div><div class="line">    <span class="comment">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry  </span></div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);  </div><div class="line">    <span class="comment">// 如果 Map 中的 key-value 对的数量超过了极限  </span></div><div class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)  </div><div class="line">    <span class="comment">// 把 table 对象的长度扩充到原来的2倍。  </span></div><div class="line">        resize(<span class="number">2</span> * table.length);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p>hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);  </div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法非常巧妙，它通过h&amp;(table.length-1)来得到该对象的保存位，而HashMap底层数组的长度总是 2 的 n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)  </div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。当length总是 2 的n次方时，h&amp;(length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>这看上去很简单，其实比较有玄机的，我们举个例子来说明：假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：</p>
<table>
<thead>
<tr>
<th>h &amp; (table.length-1)</th>
<th>hash</th>
<th></th>
<th>table.length-1</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>8 &amp; (15-1)：</td>
<td>0100</td>
<td>&amp;</td>
<td>1110</td>
<td>=</td>
<td>0100</td>
</tr>
<tr>
<td>9 &amp; (15-1)：</td>
<td>0101</td>
<td>&amp;</td>
<td>1110</td>
<td>=</td>
<td>0100</td>
</tr>
<tr>
<td>8 &amp; (16-1)：</td>
<td>0100</td>
<td>&amp;</td>
<td>1111</td>
<td>=</td>
<td>0100</td>
</tr>
<tr>
<td>9 &amp; (16-1)：</td>
<td>0101</td>
<td>&amp;</td>
<td>1111</td>
<td>=</td>
<td>0101</td>
</tr>
</tbody>
</table>
<p>从上面的例子中可以看出：当它们和15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与15-1（1110）进行“与”，那么 最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<p>根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：</p>
<p><strong>如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</strong></p>
<h4 id="2-读取"><a href="#2-读取" class="headerlink" title="2. 读取"></a>2. 读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">return</span> getForNullKey();  </div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </div><div class="line">        e != <span class="keyword">null</span>;  </div><div class="line">        e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </div><div class="line">            <span class="keyword">return</span> e.value;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<p>归纳起来简单地说，<strong>HashMap 在底层将 key-value当成一个整体进行处理</strong>，这个整体就是一个 Entry 对象。HashMap 底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p>
<h3 id="HashMap的resize（rehash）"><a href="#HashMap的resize（rehash）" class="headerlink" title="HashMap的resize（rehash）"></a>HashMap的resize（rehash）</h3><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>那么HashMap什么时候进行扩容呢？</p>
<p>当HashMap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16<em>0.75=12的时候，就把数组的大小扩展为2</em>16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以<strong>如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能</strong>。</p>
<h3 id="HashMap的性能参数"><a href="#HashMap的性能参数" class="headerlink" title="HashMap的性能参数"></a>HashMap的性能参数</h3><p>HashMap 包含如下几个构造器：</p>
<ul>
<li>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity)：构建一个负载因子为0.75的HashMap,初始容量是大于initialCapacity的最小的2的n次幂。如initialCapacity=6，那么初始容量为8.</li>
<li>HashMap(int initialCapacity,floatloadFactor)：以指定初始容量、指定的负载因子创建一个HashMap。</li>
<li>HashMap的基础构造器HashMap(int initialCapacity,floatloadFactor)带有两个参数，它们是初始容量initialCapacity和加载因子loadFactor。</li>
<li>initialCapacity：HashMap的最大容量，即为底层数组的长度。</li>
<li>loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。</li>
</ul>
<p>负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。</p>
<p>HashMap的实现中，通过threshold字段来判断HashMap的最大容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</div></pre></td></tr></table></figure>
<p>结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (size++ &gt;= threshold)     </div><div class="line">    resize(<span class="number">2</span> * table.length);</div></pre></td></tr></table></figure>
<h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p><strong>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</strong></p>
<p>这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashIterator() &#123;  </div><div class="line">    expectedModCount = modCount;  </div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry  </span></div><div class="line">    Entry[] t = table;  </div><div class="line">    <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)  </div><div class="line">        ;  </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map</p>
<p>注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;     </div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount)     </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div></pre></td></tr></table></figure>
<p>在HashMap的API中指出：<br>由所有HashMap类的“collection视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java集合学习系列：HashSet的实现原理]]></title>
      <url>/java/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%9AHashSet%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本章转载自：<a href="http://zhangshixi.iteye.com/blog/673143" target="_blank" rel="external">http://zhangshixi.iteye.com/blog/673143</a></p>
<h3 id="HashSet概述"><a href="#HashSet概述" class="headerlink" title="HashSet概述"></a>HashSet概述</h3><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</p>
<h3 id="HashSet的实现"><a href="#HashSet的实现" class="headerlink" title="HashSet的实现"></a>HashSet的实现</h3><p>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成， HashSet的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">// 底层使用HashMap来保存HashSet中所有元素。  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </div><div class="line">      </div><div class="line">    <span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 默认的无参构造器，构造一个空的HashSet。 </div><div class="line">     *  </div><div class="line">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 构造一个包含指定collection中的元素的新set。 </div><div class="line">     * </div><div class="line">     * 实际底层使用默认的加载因子0.75和足以包含指定 </div><div class="line">     * collection中所有元素的初始容量来创建一个HashMap。 </div><div class="line">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));  </div><div class="line">    addAll(c);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数构造一个空的HashMap。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 以指定的initialCapacity构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </div><div class="line">     * </div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。 </div><div class="line">     * <span class="doctag">@param</span> dummy 标记。 </div><div class="line">     */  </div><div class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;  </div><div class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </div><div class="line">     *  </div><div class="line">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </div><div class="line">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </div><div class="line">     * value使用一个static final的Object对象标识。 </div><div class="line">     * <span class="doctag">@return</span> 对此set中元素进行迭代的Iterator。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.keySet().iterator();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 返回此set中的元素的数量（set的容量）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </div><div class="line">     * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.size();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果此set不包含任何元素，则返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </div><div class="line">     * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.isEmpty();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果此set包含指定元素，则返回true。 </div><div class="line">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </div><div class="line">     * 的e元素时，返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </div><div class="line">     * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。 </div><div class="line">     * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.containsKey(o);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果此set中尚未包含指定元素，则添加指定元素。 </div><div class="line">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </div><div class="line">     * 的元素e2，则向此set 添加指定的元素e。 </div><div class="line">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </div><div class="line">     * </div><div class="line">     * 底层实际将将该元素作为key放入HashMap。 </div><div class="line">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </div><div class="line">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </div><div class="line">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </div><div class="line">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </div><div class="line">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </div><div class="line">     * <span class="doctag">@param</span> e 将添加到此set中的元素。 </div><div class="line">     * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果指定元素存在于此set中，则将其移除。 </div><div class="line">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </div><div class="line">     * 则将其移除。如果此set已包含该元素，则返回true </div><div class="line">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的remove方法删除指定Entry。 </div><div class="line">     * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。 </div><div class="line">     * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </div><div class="line">    map.clear();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();  </div><div class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line">            <span class="keyword">return</span> newSet;  </div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h3><ul>
<li>相关HashMap的实现原理，请参考上一遍总结：深入Java集合学习系列：HashMap的实现原理。</li>
<li><strong>对于HashSet中保存的对象，请注意正确重写其equals和hashCode方法，以保证放入的对象的唯一性。</strong></li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java集合学习系列：LinkedHashSet的实现原理]]></title>
      <url>/java/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%9ALinkedHashSet%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本章转载自：<a href="http://zhangshixi.iteye.com/blog/673319" target="_blank" rel="external">http://zhangshixi.iteye.com/blog/673319</a></p>
<h3 id="LinkedHashSet概述"><a href="#LinkedHashSet概述" class="headerlink" title="LinkedHashSet概述"></a>LinkedHashSet概述</h3><p>LinkedHashSet是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。此实现与HashSet的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</p>
<p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步。</p>
<h3 id="LinkedHashSet的实现"><a href="#LinkedHashSet的实现" class="headerlink" title="LinkedHashSet的实现"></a>LinkedHashSet的实现</h3><p>对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。</p>
<p>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。LinkedHashSet的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 构造一个带有指定初始容量和加载因子的新空链接哈希set。 </div><div class="line">     * </div><div class="line">     * 底层会调用父类的构造方法，构造一个有指定初始容量和加载因子的LinkedHashMap实例。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 构造一个带指定初始容量和默认加载因子0.75的新空链接哈希set。 </div><div class="line">     * </div><div class="line">     * 底层会调用父类的构造方法，构造一个带指定初始容量和默认加载因子0.75的LinkedHashMap实例。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 构造一个带默认初始容量16和加载因子0.75的新空链接哈希set。 </div><div class="line">     * </div><div class="line">     * 底层会调用父类的构造方法，构造一个带默认初始容量16和加载因子0.75的LinkedHashMap实例。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 构造一个与指定collection中的元素相同的新链接哈希set。 </div><div class="line">     *  </div><div class="line">     * 底层会调用父类的构造方法，构造一个足以包含指定collection </div><div class="line">     * 中所有元素的初始容量和加载因子为0.75的LinkedHashMap实例。 </div><div class="line">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);  </div><div class="line">        addAll(c);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在父类HashSet中，专为LinkedHashSet提供的构造方法如下，该方法为包访问权限，并未对外公开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </div><div class="line">     * </div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。 </div><div class="line">     * <span class="doctag">@param</span> dummy 标记。 </div><div class="line">     */  </div><div class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;  </div><div class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由上述源代码可见，LinkedHashSet通过继承HashSet，底层使用LinkedHashMap，以很简单明了的方式来实现了其自身的所有功能。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java集合学习系列：LinkedHashMap的实现原理]]></title>
      <url>/java/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%9ALinkedHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本章转载自：<a href="http://zhangshixi.iteye.com/blog/673789" target="_blank" rel="external">http://zhangshixi.iteye.com/blog/673789</a></p>
<h3 id="LinkedHashMap概述"><a href="#LinkedHashMap概述" class="headerlink" title="LinkedHashMap概述"></a>LinkedHashMap概述</h3><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。<strong>此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</strong></p>
<p><strong>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表</strong>。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p>
<p><strong>注意，此实现不是同步的</strong>。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p>
<h3 id="LinkedHashMap的实现"><a href="#LinkedHashMap的实现" class="headerlink" title="LinkedHashMap的实现"></a>LinkedHashMap的实现</h3><p>对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。下面我们来分析LinkedHashMap的源代码。</p>
<h4 id="1-Entry元素"><a href="#1-Entry元素" class="headerlink" title="1. Entry元素"></a>1. Entry元素</h4><p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 双向链表的表头元素。 </div><div class="line"> */  </div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;  </div><div class="line">  </div><div class="line"><span class="comment">/** </span></div><div class="line"> * LinkedHashMap的Entry元素。 </div><div class="line"> * 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 </div><div class="line"> */  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    Entry&lt;K,V&gt; before, after;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><p>通过源代码可以看出，在LinkedHashMap的构造方法中，实际调用了父类HashMap的相关构造方法来构造一个底层存放的table数组。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);  </div><div class="line">    accessOrder = <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap中的相关构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +  </div><div class="line">                                           initialCapacity);  </div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;  </div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  </div><div class="line">                                           loadFactor);  </div><div class="line">  </div><div class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity  </span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)  </div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </div><div class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);  </div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];  </div><div class="line">    init();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在上述HashMap的构造器中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中并无意义，只是提供给子类实现相关的初始化调用。</p>
<p>LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </div><div class="line">    header = <span class="keyword">new</span> Entry&lt;K,V&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </div><div class="line">    header.before = header.after = header;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-存储"><a href="#3-存储" class="headerlink" title="3. 存储"></a>3. 存储</h4><p>LinkedHashMap并未重写父类HashMap的put方法，而是重写了父类HashMap的put方法调用的子方法void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash,K key,V value,int bucketIndex)，提供了自己特有的双向链接列表的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 调用create方法，将新元素以双向链表的的形式加入到映射中。  </span></div><div class="line">    createEntry(hash, key, value, bucketIndex);  </div><div class="line">  </div><div class="line">    <span class="comment">// 删除最近最少使用元素的策略定义  </span></div><div class="line">    Entry&lt;K,V&gt; eldest = header.after;  </div><div class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;  </div><div class="line">        removeEntryForKey(eldest.key);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">if</span> (size &gt;= threshold)  </div><div class="line">            resize(<span class="number">2</span> * table.length);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </div><div class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  </div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);  </div><div class="line">    table[bucketIndex] = e;  </div><div class="line">    <span class="comment">// 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。  </span></div><div class="line">    e.addBefore(header);  </div><div class="line">    size++;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;  </div><div class="line">    after  = existingEntry;  </div><div class="line">    before = existingEntry.before;  </div><div class="line">    before.after = <span class="keyword">this</span>;  </div><div class="line">    after.before = <span class="keyword">this</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-读取"><a href="#4-读取" class="headerlink" title="4. 读取"></a>4. 读取</h4><p>LinkedHashMap重写了父类HashMap的get方法，实际在调用父类getEntry()方法取得查找的元素后，再判断当排序模式accessOrder为true时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 调用父类HashMap的getEntry()方法，取得要查找的元素。  </span></div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);  </div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    <span class="comment">// 记录访问顺序。  </span></div><div class="line">    e.recordAccess(<span class="keyword">this</span>);  </div><div class="line">    <span class="keyword">return</span> e.value;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  </div><div class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  </div><div class="line">    <span class="comment">// 如果定义了LinkedHashMap的迭代顺序为访问顺序，  </span></div><div class="line">    <span class="comment">// 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。  </span></div><div class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;  </div><div class="line">        lm.modCount++;  </div><div class="line">        remove();  </div><div class="line">        addBefore(lm.header);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-排序模式"><a href="#5-排序模式" class="headerlink" title="5. 排序模式"></a>5. 排序模式</h4><p>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div></pre></td></tr></table></figure>
<p> 一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。看LinkedHashMap的构造方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);  </div><div class="line">    accessOrder = <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造LinkedHashMap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,  </span></span></div><div class="line">         <span class="keyword">float</span> loadFactor,  </div><div class="line">                     <span class="keyword">boolean</span> accessOrder) &#123;  </div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);  </div><div class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种映射很适合构建LRU缓存。LinkedHashMap提供了removeEldestEntry(Map.Entry<k,v>eldest)方法，在将新条目插入到映射后，put和 putAll将调用此方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法通常不以任何方式修改映射，相反允许映射在其返回值的指引下进行自我修改。如果用此映射构建LRU缓存，则非常方便，它允许映射通过删除旧条目来减少内存损耗。</p>
<p>例如：重写此方法，维持此映射只保存100个条目的稳定状态，在每次添加新条目时删除最旧的条目。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> size() &gt; MAX_ENTRIES;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java去除List中重复的元素]]></title>
      <url>/java/java%E5%8E%BB%E9%99%A4List%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      <content type="html"><![CDATA[<p>之前再项目中碰到了需要对一个list做去重处理的需求，并且list中的元素为对象，因此归纳总结了一下关于list去重的几种操作。</p>
<p>实体类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> String id;  </div><div class="line"><span class="keyword">public</span> String name;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id,String name)</span> </span>&#123;  </div><div class="line"><span class="keyword">this</span>.id = id;  </div><div class="line"><span class="keyword">this</span>.name = name;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="keyword">return</span> id;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;  </div><div class="line"><span class="keyword">this</span>.id = id;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line"><span class="keyword">return</span> name;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line"><span class="keyword">this</span>.name = name;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-通过HashSet踢除重复元素"><a href="#1-通过HashSet踢除重复元素" class="headerlink" title="1. 通过HashSet踢除重复元素"></a>1. 通过HashSet踢除重复元素</h4><p>首先需要重写实体类中的boolean   equals(Object   obj)   和int   hashCode()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </div><div class="line">Student s=(Student)obj;   </div><div class="line"><span class="keyword">return</span> id.equals(s.id) &amp;&amp; name.equals(s.name);   </div><div class="line">&#125;  </div><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </div><div class="line">String in = id + name;  </div><div class="line"><span class="keyword">return</span> in.hashCode();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.HashSet;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line"><span class="keyword">import</span> java.util.Set;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuSame</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        List&lt;Student&gt; stu = <span class="keyword">new</span> ArrayList&lt;Student&gt;();  </div><div class="line">        stu.add(<span class="keyword">new</span> Student(<span class="string">"1"</span>,<span class="string">"yi"</span>));  </div><div class="line">        stu.add(<span class="keyword">new</span> Student(<span class="string">"3"</span>,<span class="string">"san"</span>));  </div><div class="line">        stu.add(<span class="keyword">new</span> Student(<span class="string">"3"</span>,<span class="string">"san"</span>));  </div><div class="line">        stu.add(<span class="keyword">new</span> Student(<span class="string">"2"</span>,<span class="string">"er"</span>));  </div><div class="line">        stu.add(<span class="keyword">new</span> Student(<span class="string">"2"</span>,<span class="string">"er"</span>));  </div><div class="line">        <span class="comment">//set集合保存的是引用不同地址的对象  </span></div><div class="line">        Set&lt;Student&gt; ts = <span class="keyword">new</span> HashSet&lt;Student&gt;();  </div><div class="line">        ts.addAll(stu);  </div><div class="line">          </div><div class="line">        <span class="keyword">for</span> (Student student : ts) &#123;  </div><div class="line">            System.out.println(student.getId()+<span class="string">"-"</span>+student.getName());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-循环元素删除"><a href="#2-循环元素删除" class="headerlink" title="2. 循环元素删除"></a>2. 循环元素删除</h4><p>同样，需要重写equals和hashCode方法。</p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; stu.size() - <span class="number">1</span> ; i ++ ) &#123;</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = stu.size() - <span class="number">1</span> ; j &gt; i; j -- ) &#123;</div><div class="line">        <span class="keyword">if</span> (stu.get(j).equals(stu.get(i))) &#123;</div><div class="line">            stu.remove(j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (Student student : stu) &#123;</div><div class="line">    System.out.println(student.getId()+<span class="string">"-"</span>+student.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-删除ArrayList中重复元素，保持顺序"><a href="#3-删除ArrayList中重复元素，保持顺序" class="headerlink" title="3. 删除ArrayList中重复元素，保持顺序"></a>3. 删除ArrayList中重复元素，保持顺序</h4><p>同样，需要重写equals和hashCode方法。</p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Set set = <span class="keyword">new</span> HashSet();</div><div class="line">List newList = <span class="keyword">new</span> ArrayList();</div><div class="line"><span class="keyword">for</span> (Iterator iter = stu.iterator(); iter.hasNext();) &#123;</div><div class="line">    Object element = iter.next();</div><div class="line">    <span class="keyword">if</span> (set.add(element))</div><div class="line">        newList.add(element);</div><div class="line">&#125;</div><div class="line">stu.clear();</div><div class="line">stu.addAll(newList);</div><div class="line"><span class="keyword">for</span> (Student student : stu) &#123;</div><div class="line">    System.out.println(student.getId()+<span class="string">"-"</span>+student.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-把list里的对象遍历一遍，用list-contain-，如果不存在就放入到另外一个list集合中"><a href="#4-把list里的对象遍历一遍，用list-contain-，如果不存在就放入到另外一个list集合中" class="headerlink" title="4. 把list里的对象遍历一遍，用list.contain()，如果不存在就放入到另外一个list集合中"></a>4. 把list里的对象遍历一遍，用list.contain()，如果不存在就放入到另外一个list集合中</h4><p>同样，需要重写equals和hashCode方法。</p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;Student&gt; listTemp = <span class="keyword">new</span> ArrayList();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stu.size();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!listTemp.contains(stu.get(i)))&#123;</div><div class="line">        listTemp.add(stu.get(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (Student student : listTemp) &#123;</div><div class="line">    System.out.println(student.getId()+<span class="string">"-"</span>+student.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>如果list中对象为基本类型时，可省略equals和hashCode方法</strong></p>
<p><strong>推荐使用set方法</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[判断Map集合对象中是否包含指定的键名或键值]]></title>
      <url>/java/%E5%88%A4%E6%96%ADMap%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%AE%E5%90%8D%E6%88%96%E9%94%AE%E5%80%BC/</url>
      <content type="html"><![CDATA[<h4 id="containsKey-Object-key"><a href="#containsKey-Object-key" class="headerlink" title="containsKey(Object key)"></a>containsKey(Object key)</h4><p><strong>首先使用HashMap类创建Map集合对象，并向集合中添加几个元素，然后调用containsKey方法查询是否包含指定的键名。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Map map = <span class="keyword">new</span> HashMap();       <span class="comment">//定义Map对象</span></div><div class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"新鲜的苹果"</span>);      <span class="comment">//向集合中添加对象</span></div><div class="line">    map.put(<span class="string">"computer"</span>, <span class="string">"配置优良的计算机"</span>);</div><div class="line">    map.put(<span class="string">"book"</span>, <span class="string">"堆积成山的图书"</span>);</div><div class="line">    map.put(<span class="string">"time"</span>, <span class="keyword">new</span> Date());</div><div class="line">    String key = <span class="string">"book"</span>;</div><div class="line">    <span class="keyword">boolean</span> contains = map.containsKey(key);    <span class="comment">//判断是否包含指定的键值</span></div><div class="line">    <span class="keyword">if</span> (contains) &#123;         <span class="comment">//如果条件为真</span></div><div class="line">        System.out.println(<span class="string">"在Map集合中包含键名"</span> + key); <span class="comment">//输出信息</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"在Map集合中不包含键名"</span> + key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="containsValue-Object-value"><a href="#containsValue-Object-value" class="headerlink" title="containsValue(Object value)"></a>containsValue(Object value)</h4><p><strong>使用HashMap类创建Map集合对象，并向集合中添加几个元素，然后调用containsValue方法查询是否包含指定的键值对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Map map = <span class="keyword">new</span> HashMap();     <span class="comment">//定义Map集合对象</span></div><div class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"新鲜的苹果"</span>);    <span class="comment">//向对象添加元素</span></div><div class="line">    map.put(<span class="string">"computer"</span>, <span class="string">"配置优良的计算机"</span>);</div><div class="line">    map.put(<span class="string">"book"</span>, <span class="string">"堆积成山的图书"</span>);</div><div class="line">    map.put(<span class="string">"time"</span>, <span class="keyword">new</span> Date());</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(<span class="number">1000</span>);      <span class="comment">//休眠1秒，使两个Date对象不相等</span></div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    Date value = <span class="keyword">new</span> Date();     <span class="comment">//创建日期时间对象</span></div><div class="line">    <span class="keyword">boolean</span> contains = map.containsValue(value); <span class="comment">//判断集合中是否包含指定的value值</span></div><div class="line">    <span class="keyword">if</span> (contains) &#123;       <span class="comment">//如果条件成立</span></div><div class="line">        System.out.println(<span class="string">"在Map集合中包含键值"</span> + value); <span class="comment">//输出信息</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"在Map集合中不包含键值"</span> + value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java.util.Collections类]]></title>
      <url>/java/java.util.Collections%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p><strong>彬哥说java.util.Collections真的是个很不错的工具类.下面摘记一些方法.</strong></p>
<h4 id="返回空集合-返回的集合为只读的集合"><a href="#返回空集合-返回的集合为只读的集合" class="headerlink" title="返回空集合.(返回的集合为只读的集合)."></a>返回空集合.(返回的集合为只读的集合).</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Collections.EMPTY_SLIST;</div><div class="line">Collections.emptyList();</div><div class="line">Collections.EMPTY_MAP;</div><div class="line">Collections.emptyMap();</div><div class="line">Collections.EMPTY_SET;</div><div class="line">Collections.emptySet();</div></pre></td></tr></table></figure>
<p>所说的只读的空集合,就是指返回的集合中没有任何元素,并且向其中添加元素会抛出异常. </p>
<h4 id="返回单元素集合-返回的集合也是只读的-只不过仅仅包含一个元素"><a href="#返回单元素集合-返回的集合也是只读的-只不过仅仅包含一个元素" class="headerlink" title="返回单元素集合.(返回的集合也是只读的,只不过仅仅包含一个元素)"></a>返回单元素集合.(返回的集合也是只读的,只不过仅仅包含一个元素)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.singletonList();<span class="comment">//单元素只读List</span></div><div class="line">Collections.singletonMap();<span class="comment">//单元素只读Map</span></div><div class="line">Collections.singleton();<span class="comment">//单元素只读Set,此处函数名没有包含set</span></div></pre></td></tr></table></figure>
<h4 id="其他的一些方法"><a href="#其他的一些方法" class="headerlink" title="其他的一些方法"></a>其他的一些方法</h4><ul>
<li><strong>查找替换fill:</strong>  使用指定元素替换指定列表中的所有元素。</li>
<li><strong>frequency:</strong>  返回指定 collection 中等于指定对象的元素数。</li>
<li><strong>indexOfSubList:</strong> 返回指定源列表中第一次出现指定目标列表的起始位置，如果没有出现这样的列表，则返回 -1。</li>
<li><strong>lastIndexOfSubList:</strong>返回指定源列表中最后一次出现指定目标列表的起始位置，如果没有出现这样的列表，则返回-1。</li>
<li><strong>max:</strong>  根据元素的自然顺序，返回给定 collection 的最大元素。</li>
<li><strong>min:</strong>  根据元素的自然顺序 返回给定 collection 的最小元素。</li>
<li><strong>replaceAll:</strong>  使用另一个值替换列表中出现的所有某一指定值。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> util </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Collection集合遍历时,使用foreach和iterator迭代器的区别]]></title>
      <url>/java/Collection%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%97%B6,%E4%BD%BF%E7%94%A8foreach%E5%92%8Citerator%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>集合在循环遍历时候,有两种常用方式:</p>
<h4 id="一种foreach方式"><a href="#一种foreach方式" class="headerlink" title="一种foreach方式:"></a>一种foreach方式:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Object o : collection)&#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="另一种iterator迭代器方式"><a href="#另一种iterator迭代器方式" class="headerlink" title="另一种iterator迭代器方式:"></a>另一种iterator迭代器方式:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Iterator iter = collection.iterator();iter.hasNext())&#123;&#125;</div><div class="line"><span class="comment">//或者</span></div><div class="line"><span class="keyword">while</span>(collection.iterator().hasNext())&#123;Object o = collection.iterator().next()&#125;</div></pre></td></tr></table></figure>
<p>foreach方式比较简洁,不容易出错,不必关心下表的起始值和终止值,但是其最终还是iterator来实现的.</p>
<p>两种方式的区别就是在于它们的remove()方法上,如果你有需求需要循环删除元素,就不能调用集合的remove()方法,会导致循环出错.这时候就需要使用iterator迭代器的remove()方法.</p>
<p>循环过程中list.size()的大小变化了，就导致了错误。 所以，如果想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法，因为它的remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。</p>
<p>forEach就是为了让用iterator循环访问的形式简单，写起来更方便。当然功能不太全,所以但如有删除操作，还是要用它原来的形式。</p>
<p>参考资料:<a href="http://note.youdao.com/" target="_blank" rel="external">http://blog.csdn.net/zxq1138634642/article/details/8092327</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈LinkList和ArrayList的一些区别]]></title>
      <url>/java/%E6%B5%85%E8%B0%88LinkList%E5%92%8CArrayList%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><strong>一般大家都知道的几个基本的区别：</strong></p>
<ul>
<li>ArrayList是动态数组的数据结构，LinkList是基于链表的数据结构。</li>
<li>随机的get和set访问List，一般都用ArrayList，因为LinkList需要移动指针来访问。</li>
<li>对于add和remove相关操作，则LinkList的操作效率高，因为它只需要操作指针，而ArrayList需要移动数据。（此点只是针对大量或多条数据而言，单一的数据的话，ArrayList效率&gt;LinkList效率。但若是大量的批量随机插入或者删除数据则相反，因为每插入一条数据ArrayList都要把即将插入的这条数据所处的index的后面的所有数据往后移动一位，这点使得ArrayList的效率变得没有LinkList那么高，相对的，LinkList只需要操作相应指针即可。）</li>
<li>对于在List查找相关的操作（indexOf/contains等）效率应该是差不多的。</li>
<li>随机查找指定的节点的操作，大多是：ArrayList&gt;LinkList，在末尾插入数据例外。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[abstract class和interface]]></title>
      <url>/java/abstract%20class%E5%92%8Cinterface/</url>
      <content type="html"><![CDATA[<p>大致的来说，interface也许算是abstract class的变体，都不可以实例化。只不过有些地方有区别，比如子类：interface是实现（还可以多个），abstract class是继承（单个）。</p>
<p>比较</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员变量</td>
<td>可以拥有自己的成员变量</td>
<td>如果要有必须为 static final</td>
<td></td>
</tr>
<tr>
<td>方法类型</td>
<td>private、不是abstract</td>
<td>public abstract</td>
<td></td>
</tr>
<tr>
<td>实例化</td>
<td>不可以实例化，且子类都必须实现已声明的抽象方法</td>
<td>同</td>
<td></td>
</tr>
<tr>
<td>子类数量</td>
<td>一个类只能继承一个abstract class</td>
<td>一个类实现多个interface</td>
<td></td>
</tr>
<tr>
<td>子类的方法</td>
<td>可以选择性的实现哪些方法</td>
<td>某个方法必须实现</td>
<td></td>
</tr>
<tr>
<td>与子类的联系</td>
<td>abstract class中可以有非抽象的方法，子类中是必须实现有abstract的方法。非abstract方法可以选择继承或者重写覆盖。</td>
<td>interface中的方法都是抽象的，而且默认的都是public，且不能声明private和protected。</td>
<td></td>
</tr>
<tr>
<td>使用场景</td>
<td>重要的就是需要一个统一的接口并且需要声明一个变量的情况，不希望也不需要子类实现所有的方法，只需要子类实现某些特定的方法。并且可以有共用的方法，也可以考虑abstract class。</td>
<td>不在乎他的子类是如何实现的，只需要保证接口一致的协调性。需要多种类型的方法，但是又是分开写的互不干扰，可以选择interface的形式。</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>注：interface 可以拿来定义一些常量，而不使用static class来定义。</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> interface </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
