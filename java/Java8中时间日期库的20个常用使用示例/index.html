<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>Java8中时间日期库的20个常用使用示例 - Meow's Blog</title><meta name="description" content="除了lambda表达式，stream以及几个小的改进之外，Java8还引入了一套全新的时间日期API，新的时间及日期API位于java.time包中，下面是里面的一些关键的类：Instant——它代表的是时间戳LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，"><link type="text/css" rel="stylesheet" href="/css/basic.css?v=0.0.0"><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.0"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java8中时间日期库的20个常用使用示例</h1><a id="logo" href="/.">Meow's Blog</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span></div></div></div></div><script type="text/javascript" color="255,102,102" opacity="0.7" zIndex="-2" count="140" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java8中时间日期库的20个常用使用示例</h1><div class="post-meta">Nov 7, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" type="text/javascript"></script><span class="meta-space">  |  </span><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span><span> 浏览</span></span></div><div class="post-content"><p>除了lambda表达式，stream以及几个小的改进之外，Java8还引入了一套全新的时间日期API，新的时间及日期API位于java.time包中，下面是里面的一些关键的类：</p>
<ul>
<li>Instant——它代表的是时间戳</li>
<li>LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</li>
<li>LocalTime——它代表的是不含日期的时间</li>
<li>LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。</li>
<li>ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。<br>新的库还增加了ZoneOffset及Zoned，可以为时区提供更好的支持。<br>以下为相关示例：<h4 id="1-如何-在Java-8中获取当天的日期"><a href="#1-如何-在Java-8中获取当天的日期" class="headerlink" title="1. 如何 在Java 8中获取当天的日期"></a>1. 如何 在Java 8中获取当天的日期</h4>Java 8中有一个叫LocalDate的类，它能用来表示今天的日期。这个类与java.util.Date略有不同，因为它只包含日期，没有时间。因此，如果你只需要表示日期而不包含时间，就可以使用它。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now(); System.out.println(<span class="string">"Today's Local date : "</span> + today);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Today&apos;s Local date : 2014-01-14</div></pre></td></tr></table></figure></p>
<p>你可以看到它创建了今天的日期却不包含时间信息。它还将日期格式化完了再输出出来，不像之前的Date类那样，打印出来的数据都是未经格式化的。</p>
<h4 id="2-如何在Java-8中获取当前的年月日"><a href="#2-如何在Java-8中获取当前的年月日" class="headerlink" title="2. 如何在Java 8中获取当前的年月日"></a>2. 如何在Java 8中获取当前的年月日</h4><p>LocalDate类中提供了一些很方便的方法可以用于提取出年月日以及其它的日期属性。使用这些方法，你可以获取到任何你所需要的日期属性，而不再需要使用java.util.Calendar这样的类了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now(); </div><div class="line"><span class="keyword">int</span> year = today.getYear(); </div><div class="line"><span class="keyword">int</span> month = today.getMonthValue(); </div><div class="line"><span class="keyword">int</span> day = today.getDayOfMonth(); </div><div class="line">System.out.printf(<span class="string">"Year : %d Month : %d day : %d \t %n"</span>, year, month, day);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Today&apos;s Local date : 2014-01-14 </div><div class="line">Year : 2014 Month : 1 day : 14</div></pre></td></tr></table></figure></p>
<p>可以看到，在Java 8中获取年月信息非常简单，只需使用对应的getter方法就好了，无需记忆，非常直观。你可以拿它和Java中老的获取当前年月日的写法进行一下比较。</p>
<h4 id="3-在Java-8中如何获取某个特定的日期"><a href="#3-在Java-8中如何获取某个特定的日期" class="headerlink" title="3. 在Java 8中如何获取某个特定的日期"></a>3. 在Java 8中如何获取某个特定的日期</h4><p>在第一个例子中，我们看到通过静态方法now()来生成当天日期是非常简单的，不过通过另一个十分有用的工厂方法LocalDate.of()，则可以创建出任意一个日期，它接受年月日的参数，然后返回一个等价的LocalDate实例。关于这个方法还有一个好消息就是它没有再犯之前API中的错，比方说，年只能从1900年开始，月必须从0开始，等等。这里的日期你写什么就是什么，比如说，下面这个例子中它代表的就是1月14日，没有什么隐藏逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>); </div><div class="line">System.out.println(<span class="string">"Your Date of birth is : "</span> + dateOfBirth);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Your Date of birth is : 2010-01-14</div></pre></td></tr></table></figure></p>
<h4 id="4-在Java-8中如何检查两个日期是否相等"><a href="#4-在Java-8中如何检查两个日期是否相等" class="headerlink" title="4. 在Java 8中如何检查两个日期是否相等"></a>4. 在Java 8中如何检查两个日期是否相等</h4><p>如果说起现实中实际的处理时间及日期的任务，有一个常见的就是要检查两个日期是否相等。你可能经常会碰到要判断今天是不是某个特殊的日子，比如生日啊，周年纪念日啊，或者假期之类。有的时候，会给你一个日期，让你检查它是不是某个日子比方说假日。下面这个例子将会帮助你在Java 8中完成这类任务。正如你所想的那样，LocalDate重写了equals方法来进行日期的比较，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">14</span>); </div><div class="line"><span class="keyword">if</span>(date1.equals(today))&#123; </div><div class="line">    System.out.printf(<span class="string">"Today %s and date1 %s are same date %n"</span>, today, date1); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">today 2014-01-14 and date1 2014-01-14 are same date</div></pre></td></tr></table></figure></p>
<p>在本例中我们比较的两个日期是相等的。同时，如果在代码中你拿到了一个格式化好的日期串，你得先将它解析成日期然后才能比较。你可以将这个例子与Java之前比较日期的方式进行下比较，你会发现它真是爽多了。</p>
<h4 id="5-在Java-8中如何检查重复事件，比如说生日"><a href="#5-在Java-8中如何检查重复事件，比如说生日" class="headerlink" title="5. 在Java 8中如何检查重复事件，比如说生日"></a>5. 在Java 8中如何检查重复事件，比如说生日</h4><p>在Java中还有一个与时间日期相关的实际任务就是检查重复事件，比如说每月的帐单日，结婚纪念日，每月还款日或者是每年交保险费的日子。如果你在一家电商公司工作的话，那么肯定会有这么一个模块，会去给用户发送生日祝福并且在每一个重要的假日给他们捎去问候，比如说圣诞节，感恩节，在印度则可能是万灯节（Deepawali）。如何在Java中判断是否是某个节日或者重复事件？使用MonthDay类。这个类由月日组合，不包含年信息，也就是说你可以用它来代表每年重复出现的一些日子。当然也有一些别的组合，比如说YearMonth类。它和新的时间日期库中的其它类一样也都是不可变且线程安全的，并且它还是一个值类（value class）。我们通过一个例子来看下如何使用MonthDay来检查某个重复的日期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>); </div><div class="line">MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth()); </div><div class="line">MonthDay currentMonthDay = MonthDay.from(today); </div><div class="line"><span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123; </div><div class="line">    System.out.println(<span class="string">"Many Many happy returns of the day !!"</span>); </div><div class="line">&#125;<span class="keyword">else</span>&#123; </div><div class="line">    System.out.println(<span class="string">"Sorry, today is not your birthday"</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Many Many happy returns of the day !!</div></pre></td></tr></table></figure></p>
<p>虽然年不同，但今天就是生日的那天，所以在输出那里你会看到一条生日祝福。你可以调整下系统的时间再运行下这个程序看看它是否能提醒你下一个生日是什么时候，你还可以试着用你的下一个生日来编写一个JUnit单元测试看看代码能否正确运行。</p>
<h4 id="6-如何在Java-8中获取当前时间"><a href="#6-如何在Java-8中获取当前时间" class="headerlink" title="6. 如何在Java 8中获取当前时间"></a>6. 如何在Java 8中获取当前时间</h4><p>这与第一个例子中获取当前日期非常相似。这次我们用的是一个叫LocalTime的类，它是没有日期的时间，与LocalDate是近亲。这里你也可以用静态工厂方法now()来获取当前时间。默认的格式是hh:mm:ss:nnn，这里的nnn是纳秒。可以和Java 8以前如何获取当前时间做一下比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime time = LocalTime.now();</div><div class="line">System.out.println(<span class="string">"local time now : "</span> + time);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Output </div><div class="line">local time now : 16:33:33.369 // in hour, minutes, seconds, nano seconds</div></pre></td></tr></table></figure>
<p>可以看到，当前时间是不包含日期的，因为LocalTime只有时间，没有日期。</p>
<h4 id="7-如何增加时间里面的小时数"><a href="#7-如何增加时间里面的小时数" class="headerlink" title="7. 如何增加时间里面的小时数"></a>7. 如何增加时间里面的小时数</h4><p>很多时候我们需要增加小时，分或者秒来计算出将来的时间。Java 8不仅提供了不可变且线程安全的类，它还提供了一些更方便的方法譬如plusHours()来替换原来的add()方法。顺便说一下，这些方法返回的是一个新的LocalTime实例的引用，因为LocalTime是不可变的，可别忘了存储好这个新的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalTime time = LocalTime.now();</div><div class="line">LocalTime newTime = time.plusHours(<span class="number">2</span>); <span class="comment">// adding two hours </span></div><div class="line">System.out.println(<span class="string">"Time after 2 hours : "</span> + newTime);</div></pre></td></tr></table></figure>
<p>Output :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time after 2 hours : 18:33:33.369</div></pre></td></tr></table></figure></p>
<p>可以看到当前时间2小时后是16:33:33.369。现在你可以将它和Java中增加或者减少小时的老的方式进行下比较。一看便知哪种方式更好。</p>
<h4 id="8-如何获取1周后的日期"><a href="#8-如何获取1周后的日期" class="headerlink" title="8. 如何获取1周后的日期"></a>8. 如何获取1周后的日期</h4><p>这与前一个获取2小时后的时间的例子类似，这里我们将学会如何获取到1周后的日期。LocalDate是用来表示无时间的日期的，它有一个plus()方法可以用来增加日，星期，或者月，ChronoUnit则用来表示这个时间单位。由于LocalDate也是不可变的，因此任何修改操作都会返回一个新的实例，因此别忘了保存起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDate nextWeek = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS); </div><div class="line">System.out.println(<span class="string">"Today is : "</span> + today); </div><div class="line">System.out.println(<span class="string">"Date after 1 week : "</span> + nextWeek);</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Today is : 2014-01-14 </div><div class="line">Date after 1 week : 2014-01-21</div></pre></td></tr></table></figure></p>
<p>可以看到7天也就是一周后的日期是什么。你可以用这个方法来增加一个月，一年，一小时，一分钟，甚至是十年，查看下Java API中的ChronoUnit类来获取更多选项。</p>
<h4 id="9-一年前后的日期"><a href="#9-一年前后的日期" class="headerlink" title="9. 一年前后的日期"></a>9. 一年前后的日期</h4><p>这是上个例子的续集。上例中，我们学习了如何使用LocalDate的plus()方法来给日期增加日，周或者月，现在我们来学习下如何用minus()方法来找出一年前的那天。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate previousYear = today.minus(<span class="number">1</span>, ChronoUnit.YEARS); </div><div class="line">System.out.println(<span class="string">"Date before 1 year : "</span> + previousYear); </div><div class="line">LocalDate nextYear = today.plus(<span class="number">1</span>, YEARS); </div><div class="line">System.out.println(<span class="string">"Date after 1 year : "</span> + nextYear);</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Date before 1 year : 2013-01-14 </div><div class="line">Date after 1 year : 2015-01-14</div></pre></td></tr></table></figure></p>
<p>可以看到现在一共有两年，一个是2013年，一个是2015年，分别是2014的前后那年。</p>
<h4 id="10-在Java-8中使用时钟"><a href="#10-在Java-8中使用时钟" class="headerlink" title="10. 在Java 8中使用时钟"></a>10. 在Java 8中使用时钟</h4><p>Java 8中自带了一个Clock类，你可以用它来获取某个时区下当前的瞬时时间，日期或者时间。可以用Clock来替代System.currentTimeInMillis()与 TimeZone.getDefault()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Returns the current time based on your system clock and set to UTC. </span></div><div class="line">Clock clock = Clock.systemUTC(); </div><div class="line">System.out.println(<span class="string">"Clock : "</span> + clock); </div><div class="line"><span class="comment">// Returns time based on system clock zone Clock defaultClock = </span></div><div class="line">Clock.systemDefaultZone(); </div><div class="line">System.out.println(<span class="string">"Clock : "</span> + clock); </div><div class="line">Output: </div><div class="line">Clock : SystemClock[Z] </div><div class="line">Clock : SystemClock[Z]</div><div class="line">你可以用指定的日期来和这个时钟进行比较，比如下面这样：</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> Clock clock; <span class="comment">// dependency inject ... </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(LocalDate eventDate)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span>(eventDate.isBefore(LocalDate.now(clock)) &#123; </div><div class="line">            ... </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你需要对不同时区的日期进行处理的话这是相当方便的。</p>
<h4 id="11-在Java中如何判断某个日期是在另一个日期的前面还是后面"><a href="#11-在Java中如何判断某个日期是在另一个日期的前面还是后面" class="headerlink" title="11. 在Java中如何判断某个日期是在另一个日期的前面还是后面"></a>11. 在Java中如何判断某个日期是在另一个日期的前面还是后面</h4><p>这也是实际项目中常见的一个任务。你怎么判断某个日期是在另一个日期的前面还是后面，或者正好相等呢？在Java 8中，LocalDate类有一个isBefore()和isAfter()方法可以用来比较两个日期。如果调用方法的那个日期比给定的日期要早的话，isBefore()方法会返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate tomorrow = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">15</span>); 、<span class="keyword">if</span>(tommorow.isAfter(today))&#123; </div><div class="line">    System.out.println(<span class="string">"Tomorrow comes after today"</span>); </div><div class="line">&#125; </div><div class="line">LocalDate yesterday = today.minus(<span class="number">1</span>, DAYS); </div><div class="line"><span class="keyword">if</span>(yesterday.isBefore(today))&#123; </div><div class="line">    System.out.println(<span class="string">"Yesterday is day before today"</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Tomorrow comes after today </div><div class="line">Yesterday is day before today</div></pre></td></tr></table></figure></p>
<p>可以看到在Java 8中进行日期比较非常简单。不需要再用像Calendar这样的另一个类来完成类似的任务了。</p>
<h4 id="12-在Java-8中处理不同的时区"><a href="#12-在Java-8中处理不同的时区" class="headerlink" title="12. 在Java 8中处理不同的时区"></a>12. 在Java 8中处理不同的时区</h4><p>Java 8不仅将日期和时间进行了分离，同时还有时区。现在已经有好几组与时区相关的类了，比如ZonId代表的是某个特定的时区，而ZonedDateTime代表的是带时区的时间。它等同于Java 8以前的GregorianCalendar类。使用这个类，你可以将本地时间转换成另一个时区中的对应时间，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Date and time with timezone in Java 8 ZoneId america = ZoneId.of("America/New_York"); </span></div><div class="line">LocalDateTime localtDateAndTime = LocalDateTime.now(); </div><div class="line">ZonedDateTime dateAndTimeInNewYork = ZonedDateTime.of(localtDateAndTime, america ); </div><div class="line">System.out.println(<span class="string">"Current date and time in a particular timezone : "</span> + dateAndTimeInNewYork);</div></pre></td></tr></table></figure>
<p>output: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Current date and time in aparticular time zone:2014-01-14T16:33:33.373-05:00[America/New_York]</div></pre></td></tr></table></figure>
<p>可以拿它跟之前将本地时间转换成GMT时间的方式进行下比较。顺便说一下，正如Java 8以前那样，对应时区的那个文本可别弄错了，否则你会碰到这么一个异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.time.zone.ZoneRulesException: Unknown time-zone ID: ASIA/Tokyo</div><div class="line">        at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:272)</div><div class="line">        at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)</div><div class="line">        at java.time.ZoneRegion.ofId(ZoneRegion.java:120)</div><div class="line">        at java.time.ZoneId.of(ZoneId.java:403)</div><div class="line">        at java.time.ZoneId.of(ZoneId.java:351)</div></pre></td></tr></table></figure>
<h4 id="13-如何表示固定的日期，比如信用卡过期时间"><a href="#13-如何表示固定的日期，比如信用卡过期时间" class="headerlink" title="13. 如何表示固定的日期，比如信用卡过期时间"></a>13. 如何表示固定的日期，比如信用卡过期时间</h4><p>正如MonthDay表示的是某个重复出现的日子的，YearMonth又是另一个组合，它代表的是像信用卡还款日，定期存款到期日，options到期日这类的日期。你可以用这个类来找出那个月有多少天，lengthOfMonth()这个方法返回的是这个YearMonth实例有多少天，这对于检查2月到底是28天还是29天可是非常有用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">YearMonth currentYearMonth = YearMonth.now(); </div><div class="line">System.out.printf(<span class="string">"Days in month year %s:%d%n"</span>,currentYearMonth,currentYearMonth.lengthOfMonth()); </div><div class="line">YearMonth creditCardExpiry = YearMonth.of(<span class="number">2018</span>, Month.FEBRUARY); </div><div class="line">System.out.printf(<span class="string">"Your credit card expires on %s %n"</span>, creditCardExpiry);</div></pre></td></tr></table></figure>
<p>output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Days in month year 2014-01: 31 </div><div class="line">Your credit card expires on 2018-02</div></pre></td></tr></table></figure>
<h4 id="14-如何在Java-8中检查闰年"><a href="#14-如何在Java-8中检查闰年" class="headerlink" title="14. 如何在Java 8中检查闰年"></a>14. 如何在Java 8中检查闰年</h4><p>这并没什么复杂的，LocalDate类有一个isLeapYear()的方法能够返回当前LocalDate对应的那年是否是闰年。如果你还想重复造轮子的话，可以看下这段代码，这是纯用Java编写的判断某年是否是闰年的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(today.isLeapYear())&#123; </div><div class="line">    System.out.println(<span class="string">"This year is Leap year"</span>); </div><div class="line">&#125;<span class="keyword">else</span> &#123; </div><div class="line">    System.out.println(<span class="string">"2014 is not a Leap year"</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2014 is not a Leap year</div></pre></td></tr></table></figure>
<h4 id="15-两个日期之间包含多少天，多少个月"><a href="#15-两个日期之间包含多少天，多少个月" class="headerlink" title="15. 两个日期之间包含多少天，多少个月"></a>15. 两个日期之间包含多少天，多少个月</h4><p>还有一个常见的任务就是计算两个给定的日期之间包含多少天，多少周或者多少年。你可以用java.time.Period类来完成这个功能。在下面这个例子中，我们将计算当前日期与将来的一个日期之前一共隔着几个月。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDate java8Release = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">14</span>); </div><div class="line">Period periodToNextJavaRelease = Period.between(today, java8Release); </div><div class="line">System.out.println(<span class="string">"Months left between today and Java 8 release : "</span> + periodToNextJavaRelease.getMonths() );</div></pre></td></tr></table></figure>
<p>output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Months left between today and Java 8 release : 2</div></pre></td></tr></table></figure>
<p>可以看到，本月是1月，而Java 8的发布日期是3月，因此中间隔着2个月。</p>
<h4 id="16-带时区偏移量的日期与时间"><a href="#16-带时区偏移量的日期与时间" class="headerlink" title="16. 带时区偏移量的日期与时间"></a>16. 带时区偏移量的日期与时间</h4><p>在Java 8里面，你可以用ZoneOffset类来代表某个时区，比如印度是GMT或者UTC5：30，你可以使用它的静态方法ZoneOffset.of()方法来获取对应的时区。只要获取到了这个偏移量，你就可以拿LocalDateTime和这个偏移量创建出一个OffsetDateTime。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDateTime datetime = LocalDateTime.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">14</span>, <span class="number">19</span>, <span class="number">30</span>); </div><div class="line">ZoneOffset offset = ZoneOffset.of(<span class="string">"+05:30"</span>);</div><div class="line">OffsetDateTime date = OffsetDateTime.of(datetime, offset); </div><div class="line">System.out.println(<span class="string">"Date and Time with timezone offset in Java : "</span> + date);</div></pre></td></tr></table></figure>
<p>Output : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Date and Time with timezone offset in Java : 2014-01-14T19:30+05:30</div></pre></td></tr></table></figure>
<p>可以看到现在时间日期与时区是关联上了。还有一点就是，OffSetDateTime主要是给机器来理解的，如果是给人看的，可以使用ZoneDateTime类。</p>
<h4 id="17-在Java-8中如何获取当前时间戳"><a href="#17-在Java-8中如何获取当前时间戳" class="headerlink" title="17. 在Java 8中如何获取当前时间戳"></a>17. 在Java 8中如何获取当前时间戳</h4><p>如果你还记得在Java 8前是如何获取当前时间戳的，那现在这简直就是小菜一碟了。Instant类有一个静态的工厂方法now()可以返回当前时间戳，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant timestamp = Instant.now(); </div><div class="line">System.out.println(<span class="string">"What is value of this instant "</span> + timestamp);</div></pre></td></tr></table></figure>
<p>Output : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">What is value of this instant 2014-01-14T08:33:33.379Z</div></pre></td></tr></table></figure>
<p>可以看出，当前时间戳是包含日期与时间的，与java.util.Date很类似，事实上Instant就是Java 8前的Date，你可以使用这两个类中的方法来在这两个类型之间进行转换，比如Date.from(Instant)是用来将Instant转换成java.util.Date的，而Date.toInstant()是将Date转换成Instant的。</p>
<h4 id="18-如何在Java-8中使用预定义的格式器来对日期进行解析-格式化"><a href="#18-如何在Java-8中使用预定义的格式器来对日期进行解析-格式化" class="headerlink" title="18. 如何在Java 8中使用预定义的格式器来对日期进行解析/格式化"></a>18. 如何在Java 8中使用预定义的格式器来对日期进行解析/格式化</h4><p>在Java 8之前，时间日期的格式化可是个技术活，我们的好伙伴SimpleDateFormat并不是线程安全的，而如果用作本地变量来格式化的话又显得有些笨重。多亏了线程本地变量，这使得它在多线程环境下也算有了用武之地，但Java维持这一状态也有很长一段时间了。这次它引入了一个全新的线程安全的日期与时间格式器。它还自带了一些预定义好的格式器，包含了常用的日期格式。比如说，本例 中我们就用了预定义的BASICISODATE格式，它会将2014年2月14日格式化成20140114。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String dayAfterTommorrow = <span class="string">"20140116"</span>; </div><div class="line">LocalDate formatted = LocalDate.parse(dayAfterTommorrow, DateTimeFormatter.BASIC_ISO_DATE); </div><div class="line">System.out.printf(<span class="string">"Date generated from String %s is %s %n"</span>, dayAfterTommorrow, formatted);</div></pre></td></tr></table></figure>
<p>Output ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Date generated from String 20140116 is 2014-01-16</div></pre></td></tr></table></figure>
<p>你可以看到生成的日期与指定字符串的值是匹配的，就是日期格式上略有不同。</p>
<h4 id="19-如何在Java中使用自定义的格式器来解析日期"><a href="#19-如何在Java中使用自定义的格式器来解析日期" class="headerlink" title="19. 如何在Java中使用自定义的格式器来解析日期"></a>19. 如何在Java中使用自定义的格式器来解析日期</h4><p>在上例中，我们使用了内建的时间日期格式器来解析日期字符串。当然了，预定义的格式器的确不错但有时候你可能还是需要使用自定义的日期格式，这个时候你就得自己去创建一个自定义的日期格式器实例了。下面这个例子中的日期格式是”MMM dd yyyy”。你可以给DateTimeFormatter的ofPattern静态方法()传入任何的模式，它会返回一个实例，这个模式的字面量与前例中是相同的。比如说M还是代表月，而m仍是分。无效的模式会抛出DateTimeParseException异常，但如果是逻辑上的错误比如说该用M的时候用成m，这样就没办法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String goodFriday = <span class="string">"Apr 18 2014"</span>; </div><div class="line"><span class="keyword">try</span> &#123; </div><div class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy"</span>);     </div><div class="line">    LocalDate holiday = LocalDate.parse(goodFriday, formatter); </div><div class="line">    System.out.printf(<span class="string">"Successfully parsed String %s, date is %s%n"</span>, goodFriday, holiday); </div><div class="line">&#125; <span class="keyword">catch</span> (DateTimeParseException ex) &#123; </div><div class="line">    System.out.printf(<span class="string">"%s is not parsable!%n"</span>, goodFriday); </div><div class="line">    ex.printStackTrace(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Successfully parsed String Apr 18 2014, date is 2014-04-18</div></pre></td></tr></table></figure>
<p>可以看到日期的值与传入的字符串的确是相符的，只是格式不同。</p>
<h4 id="20-如何在Java-8中对日期进行格式化，转换成字符串"><a href="#20-如何在Java-8中对日期进行格式化，转换成字符串" class="headerlink" title="20. 如何在Java 8中对日期进行格式化，转换成字符串"></a>20. 如何在Java 8中对日期进行格式化，转换成字符串</h4><p>在上两个例子中，尽管我们用到了DateTimeFormatter类但我们主要是进行日期字符串的解析。在这个例子中我们要做的事情正好相反。这里我们有一个LocalDateTime类的实例，我们要将它转换成一个格式化好的日期串。这是目前为止Java中将日期转换成字符串最简单便捷的方式了。下面这个例子将会返回一个格式化好的字符串。与前例相同的是，我们仍需使用指定的模式串去创建一个DateTimeFormatter类的实例，但调用的并不是LocalDate类的parse方法，而是它的format()方法。这个方法会返回一个代表当前日期的字符串，对应的模式就是传入的DateTimeFormatter实例中所定义好的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">LocalDateTime arrivalDate = LocalDateTime.now(); </div><div class="line"><span class="keyword">try</span> &#123; </div><div class="line">    DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy hh:mm a"</span>); </div><div class="line">    String landing = arrivalDate.format(format); </div><div class="line">    System.out.printf(<span class="string">"Arriving at : %s %n"</span>, landing); </div><div class="line">    &#125; <span class="keyword">catch</span> (DateTimeException ex) &#123; </div><div class="line">    System.out.printf(<span class="string">"%s can't be formatted!%n"</span>, arrivalDate); </div><div class="line">    ex.printStackTrace(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arriving at : Jan 14 2014 04:33 PM</div></pre></td></tr></table></figure>
<p>可以看到，当前时间是用给定的”MMM dd yyyy hh:mm a”模式来表示的，它包含了三个字母表示的月份以及用AM及PM来表示的时间。</p>
<h3 id="Java-8中日期与时间API的几个关键点"><a href="#Java-8中日期与时间API的几个关键点" class="headerlink" title="Java 8中日期与时间API的几个关键点"></a>Java 8中日期与时间API的几个关键点</h3><p>看完了这些例子后，我相信你已经对Java 8这套新的时间日期API有了一定的了解了。现在我们来回顾下关于这个新的API的一些关键的要素。</p>
<ol>
<li>它提供了javax.time.ZoneId用来处理时区。</li>
<li>它提供了LocalDate与LocalTime类</li>
<li>Java 8中新的时间与日期API中的所有类都是不可变且线程安全的，这与之前的Date与Calendar API中的恰好相反，那里面像java.util.Date以及SimpleDateFormat这些关键的类都不是4. 新的时间与日期API中很重要的一点是它定义清楚了基本的时间与日期的概念，比方说，瞬时时间，持续时间，日期，时间，时区以及时间段。它们都是基于ISO日历体系的。</li>
<li>每个Java开发人员都应该至少了解这套新的API中的这五个类：</li>
</ol>
<ul>
<li>Instant 它代表的是时间戳，比如2014-01-14T02:20:13.592Z，这可以从java.time.Clock类中获取，像这样： Instant current = Clock.system(ZoneId.of(“Asia/Tokyo”)).instant();</li>
<li>LocalDate 它表示的是不带时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</li>
<li>LocalTime – 它表示的是不带日期的时间</li>
<li>LocalDateTime – 它包含了时间与日期，不过没有带时区的偏移量</li>
<li>ZonedDateTime – 这是一个带时区的完整时间，它根据UTC/格林威治时间来进行时区调整</li>
</ul>
<ol>
<li>这个库的主包是java.time，里面包含了代表日期，时间，瞬时以及持续时间的类。它有两个子package，一个是java.time.foramt，这个是什么用途就很明显了，还有一个是java.time.temporal，它能从更低层面对各个字段进行访问。</li>
<li>时区指的是地球上共享同一标准时间的地区。每个时区都有一个唯一标识符，同时还有一个地区/城市(Asia/Tokyo)的格式以及从格林威治时间开始的一个偏移时间。比如说，东京的偏移时间就是+09:00。</li>
<li>OffsetDateTime类实际上包含了LocalDateTime与ZoneOffset。它用来表示一个包含格林威治时间偏移量（+/-小时：分，比如+06:00或者 -08：00）的完整的日期（年月日）及时间（时分秒，纳秒）。</li>
<li>DateTimeFormatter类用于在Java中进行日期的格式化与解析。与SimpleDateFormat不同，它是不可变且线程安全的，如果需要的话，可以赋值给一个静态变量。DateTimeFormatter类提供了许多预定义的格式器，你也可以自定义自己想要的格式。当然了，根据约定，它还有一个parse()方法是用于将字符串转换成日期的，如果转换期间出现任何错误，它会抛出DateTimeParseException异常。类似的，DateFormatter类也有一个用于格式化日期的format()方法，它出错的话则会抛出DateTimeException异常。</li>
<li>再说一句，“MMM d yyyy”与“MMm dd yyyy”这两个日期格式也略有不同，前者能识别出”Jan 2 2014″与”Jan 14 2014″这两个串，而后者如果传进来的是”Jan 2 2014″则会报错，因为它期望月份处传进来的是两个字符。为了解决这个问题，在天为个位数的情况下，你得在前面补0，比如”Jan 2 2014″应该改为”Jan 02 2014″。</li>
</ol>
</div><div class="tags"><a href="/tags/java8/">java8</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "b22222801b0e4cddb0539a007b962462",
    //因为我前面改了主题配置结构，所以上面就一级一级定位productKey了，根据自己的规则写
    target: "cloud-tie-wrapper"
};</script></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yuanwei.me"/></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/sql/">sql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内部培训/">内部培训</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习文档/">学习文档</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"><a href="/tags/面试/" style="font-size: 12px;">面试</a> <a href="/tags/sql/" style="font-size: 12px;">sql</a> <a href="/tags/git/" style="font-size: 12px;">git</a> <a href="/tags/java集合框架/" style="font-size: 18px;">java集合框架</a> <a href="/tags/interface/" style="font-size: 12px;">interface</a> <a href="/tags/tomcat/" style="font-size: 12px;">tomcat</a> <a href="/tags/util/" style="font-size: 15px;">util</a> <a href="/tags/ioc/" style="font-size: 12px;">ioc</a> <a href="/tags/nginx/" style="font-size: 12px;">nginx</a> <a href="/tags/java8/" style="font-size: 12px;">java8</a> <a href="/tags/索引/" style="font-size: 12px;">索引</a></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/sql/数据库索引/">数据库索引</a></li><li class="post-list-item"><a class="post-list-link" href="/内部培训/2017-3-6 SQL优化培训/">SQL优化培训</a></li><li class="post-list-item"><a class="post-list-link" href="/java/Java8中时间日期库的20个常用使用示例/">Java8中时间日期库的20个常用使用示例</a></li><li class="post-list-item"><a class="post-list-link" href="/java/校验算法汇总/">校验算法汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/spring/Spring Ioc与工厂模式的区别/">Spring Ioc与工厂模式的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/学习文档/java面试补习/">java面试补习</a></li><li class="post-list-item"><a class="post-list-link" href="/服务器/Apache与Tomcat的区别与联系/">Apache与Tomcat的区别与联系</a></li><li class="post-list-item"><a class="post-list-link" href="/服务器/nginx知识归纳/">nginx知识归纳</a></li><li class="post-list-item"><a class="post-list-link" href="/工具/Git 命令总结/">Git 命令总结</a></li><li class="post-list-item"><a class="post-list-link" href="/java/HashMap遍历的两种方式/">HashMap遍历的两种方式</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="http://www.wuwenbin.me" title="彬哥" target="_blank">彬哥</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Meow's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>